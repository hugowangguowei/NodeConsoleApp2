# 高光回答

## 26-02-25-00:00

### 问题：基于插槽的单选/多选技能放置，交互流程与数量约束应如何设计？

**背景要点**
- 当前流程均为：点击技能 → 点击插槽 → 完成选择，但存在两个关键缺口：
  1) 单选技能放置后仍可继续点击更多插槽（不合理；应结束或替换）。
  2) 多选技能未记录“已放置数量/上限”，导致可无限占据槽位。

**答案（推荐方案）**
将“放置”建模为一次明确的 **会话（placement session）**，用一个小型状态机统一单选/多选逻辑，并把“上限/替换/取消”规则集中起来。

1) **引入放置会话状态**（UI 层/临时态即可）
- `activeSkillId`：当前正在放置的技能
- `placementMode`：`SINGLE | MULTI`
- `maxPlacements`：本次允许占用的插槽数（单选=1；多选=配置上限）
- `selectedSlotKeys`：本次会话里已选择的插槽集合（用稳定 `slotKey` 标识）

2) **单选技能（SINGLE）的点击规则**
- 点击空插槽：放置到该插槽后，**会话立即结束**（自动退出放置模式）。
- 点击另一个空插槽：执行 **替换**（移除原插槽放置 → 放到新插槽），始终只保留 1 个。
- 点击已放置的同一插槽：视作 **取消**（移除放置；是否结束会话可按体验取舍，但要一致）。

3) **多选技能（MULTI）的点击规则**
- 点击空插槽：若 `selectedSlotKeys.size < maxPlacements` 则放置；达到上限后禁止继续放置并提示原因。
- 点击已在 `selectedSlotKeys` 中的插槽：视作 **取消该槽位的本次放置**（移除并释放计数）。
- 点击已被“其他技能/既有配置”占用的插槽：建议二选一并全局一致：
  - **禁止覆盖**：提示槽位已占用；
  - **允许覆盖**：先移除原占用再放置（会影响其它技能配置，风险更大）。

4) **上限的来源建议**
- 单选：固定为 1。
- 多选：从技能元数据或战斗规则读取，例如 `maxPlacementsPerTurn` / `maxSlots`（命名需与现有字段统一）。

5) **为什么这是系统性的**
- 行为语义集中在同一状态机里，避免 UI 事件散落条件判断；
- 便于后续把同一规则迁移到引擎层做校验，与现有“槽位容量约束”保持一致。


## 26-02-25-13:01

### 问题：我需要跟你探讨技能槽的交互是否需要放到runtime的主状态里，在我的理解中，技能和技能槽的交互是个独立交互模块，在完成全部技能的放置之后才会提交的主循环中进行下一步运算，也就是说会有一个明确的按钮来界定技能槽的交互操作已经完成。那么这种情况下是否有必要放在主状态机中进行记录？还是说可以放在一个独立的状态机中进行记录？先不要修改代码，先分析这个设计方案的合理性，并提供具体的设计建议。

你的前提（“技能放置是一个独立交互模块，完成后通过明确按钮提交，再进入主循环运算”）是合理的，而且它天然对应一种常见的架构：Planning（规划/编辑）与 Execution（执行/结算）分离。在这个前提下，“是否要把技能槽交互放进 runtime 主状态”取决于你希望系统具备哪些能力：回放一致性、存档/读档恢复、多人/网络同步、调试可追溯性、以及 UI 热更新后的稳定性。
下面分两种方案讨论，并给出我建议的折中落点。
---
1) 先澄清：这里的“主状态机”到底该管什么？
主状态机（你现在的 GameFSM + CoreEngine.battlePhase）更适合管宏观阶段：
•	BATTLE_LOOP / PLANNING / EXECUTION / SETTLEMENT
•	“是否允许修改队列/是否允许提交/是否允许执行”
而“技能槽交互”（点技能、点槽位、替换、取消、多选计数、上限提示）属于规划阶段内部的交互细节。
所以关键不是“要不要记录”，而是：
•	交互细节是否需要成为“可持久化/可还原/可校验”的引擎态数据。
---
2) 方案 A：完全放在独立交互状态机（UI 本地），提交时一次性生成结果
适用场景
•	单机、无读档恢复“本回合规划”的需求
•	不需要回放一致性（或可接受轻微差异）
•	引擎只要“最终结果”（本回合动作列表），不关心中间过程
优点
•	简单：UI 独立状态机（placement session）实现快，改 UI 不影响引擎。
•	迭代快：交互规则调整不用改 core。
缺点（通常是后期会痛的点）
•	一致性风险：UI 以为“替换/取消”成功了，但实际提交生成的列表可能与 UI 展示不同（特别是当引擎也有容量约束、目标合法性约束时）。
•	调试困难：问题发生时你只能看最终提交的数据，看不到引擎侧认为的“占用/拒绝”的原因。
•	存档/刷新丢失规划：页面刷新、本地存档恢复时，规划态很难还原。
•	多选技能更难做严谨：上限、冲突、禁止覆盖等规则如果只在 UI，未来一旦有别的入口（快捷键、脚本、AI、自动布阵）就需要重复实现。
结论：方案 A 可以用作 MVP，但只要你把“槽位”定义为核心机制，长期看会反复返工。
---
3) 方案 B：技能槽交互纳入 runtime 主状态（引擎侧规划态），UI 只是驱动器
适用场景
•	你希望“槽位规则是核心机制”，并且引擎要对其做强校验
•	需要存档/回放一致性
•	未来可能有更多入口操作 planning（技能树自动装配、AI、脚本、网络同步等）
优点
•	唯一真相来源：slotKey/占用关系在引擎里，UI 只渲染。
•	强可追溯：引擎可以记录“为什么拒绝放置”（容量、覆盖禁止、超上限、目标不合法）。
•	为多选技能铺路：多选技能的“上限计数、点击取消、替换策略”可以由引擎统一保证。
缺点
•	引擎代码会增加 planning 子状态结构与事件分发，设计要更规范。
•	交互细节如果全进主 FSM，可能导致 FSM 过于臃肿（这是你担心的点）。
关键点：把规划态数据放进 runtime，并不等于把“交互过程”放进主 FSM。主 FSM 只需知道“现在在 PLANNING”，具体交互可以由一个 planning 子模块/子状态机管理。
---
4) 我建议的折中：主 FSM 管阶段；独立 Planning 状态机/模块管交互；但“规划结果”进入 runtime
也就是“三层分离”：
(1) 主状态机（GameFSM / battlePhase）
只负责：
•	是否处于 PLANNING
•	是否允许 assign/unassign/move
•	何时 commit 进入 EXECUTION
(2) 引擎侧 Planning 模块（独立状态机/管理器）
例如概念上叫 TurnPlanner（不用现在改代码）：
•	内部维护 runtime.planning（slotKey 分配、actionsById、order、skillCounts）
•	提供命令式 API：assign(slotKey, skillId, ...) / unassign(slotKey) / move(...)
•	在 commitTurn() 时把 planning 冻结为执行队列快照（或者直接用 planning 作为执行输入）
(3) UI 交互状态机（可选，轻量）
UI 仍可保留“会话态”（当前选中技能、当前多选已选计数、提示信息）。 但 UI 不再自己维护“真实占用”，占用来自引擎 planning state。
这样你得到：
•	UI 仍然是“独立交互模块”（符合你直觉）
•	同时引擎有可校验、可持久化的规划态（支持 slotKey、多选、存档回放）
---
5) 关于“明确按钮提交”对设计的影响
有提交按钮时，规划态是天然的事务（transaction）：
•	打开规划：创建一个 planning session（可称 turnPlanningId）
•	放置/撤销：只改 session 内的 runtime.planning
•	点击提交：将 session freeze，写入 runtime.queues.player 或生成 executionPlan
•	点击重置：丢弃 session，回到初始 planning 快照
这时：
•	有必要将 planning 的结果记录到 runtime（至少要记录提交后的快照，便于回放/存档/调试）
•	是否记录“提交前的过程”则没有必要（除非你想做操作回放/撤销栈）
---
6) 具体设计建议（可直接落到文档/代码的那种粒度）
1.	runtime 增加 planning 区域（但不必进主 FSM 状态节点）
•	planning.assigned: { [slotKey]: actionId }
•	planning.actionsById: { [actionId]: action }
•	planning.skillCounts: { [skillId]: number }
•	planning.version 或 planning.sessionId（用于 UI 对齐与调试）
2.	提交按钮语义明确化（强烈建议）
•	Commit：将 planning 转为执行态输入并进入 EXECUTION
•	Reset Planning：清空 planning 回到回合初始
•	Cancel（如需要）：关闭规划 UI，但不提交（保留 planning 还是丢弃要明确）
3.	slotKey 作为引擎 API 的一等公民 UI 点击槽位时传的是 slotKey，而不是 part/targetType 让引擎自己“找第一个空位”。
这对“替换/取消/禁止覆盖/多选计数”是决定性的。
4.	多选技能支持建议
•	引擎侧为技能定义 placement.maxSlots（或等价字段），并在 assign() 时做上限校验。
•	“点击已选槽位”统一为 unassign(slotKey)（取消一格），这是多选最稳定的交互语义。
---
结论（直接回答你的问题）
•	如果你只追求快速实现、无需存档回放：可以把交互放在独立状态机里，提交时一次性生成结果（方案 A）。
•	但以你已明确的方向（槽位是核心机制、多选技能要可控、禁止覆盖、替换/取消语义要稳定）：建议把“规划结果（slotKey 占用关系）放进 runtime（引擎侧），同时把交互流程留在独立的 Planning 模块/子状态机里，主 FSM 只管 PLANNING/EXECUTION 的阶段切换（折中方案）。
如果你愿意，我可以把这套“主 FSM + TurnPlanner + runtime.planning + commit freeze”的结构整理成一段可直接写入 core_engine.md 和 UI_design.md 的规范（仍不改代码）。

