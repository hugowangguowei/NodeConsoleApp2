<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>技能编辑器原型</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --bg-color: #f4f4f4;
            --panel-bg: #ffffff;
            --border-color: #ccc;
            --primary-color: #007bff;
            --secondary-color: #2c3e50;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --light-bg: #f5f6fa;
            --monospace: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            --grid-line-color: #e0e0e0;
            --grid-size: 100px;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: var(--bg-color);
        }

        /* Layout Structure */
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* A. Toolbar */
        #toolbar {
            height: 50px;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            z-index: 100;
        }
        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: opacity 0.2s;
            margin-right: 8px;
        }
        .btn:hover { opacity: 0.9; }
        .btn-primary { background: var(--primary-color); color: #fff; }
        .btn-success { background: var(--success-color); color: #fff; }
        .btn-danger { background: var(--danger-color); color: #fff; }
        .btn-dark { background: #34495e; color: #fff; }
        .btn-sm { padding: 4px 8px; font-size: 12px; }

        #main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* B. Skill List Drawer (Left, default collapsed) */
        #skill-drawer-handle {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 12px;
            height: 96px;
            z-index: 96;
            background: rgba(0,0,0,0.08);
            border: 1px solid rgba(0,0,0,0.12);
            border-left: none;
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }
        #skill-drawer-handle::after {
            content: '';
            width: 2px;
            height: 46px;
            background: rgba(0,0,0,0.25);
            box-shadow: 4px 0 0 rgba(0,0,0,0.25), 8px 0 0 rgba(0,0,0,0.25);
        }

        #skill-drawer {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 280px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 95;
            transform: translateX(-100%);
            transition: transform 0.18s ease;
            box-shadow: 2px 0 10px rgba(0,0,0,0.08);
        }
        #skill-drawer.open {
            transform: translateX(0);
        }
        .panel-header {
            padding: 10px;
            font-weight: bold;
            background: #eee;
            border-bottom: 1px solid #ddd;
        }
        #skill-drawer-search {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        #skill-drawer-search input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-sizing: border-box;
        }

        #skill-drawer-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        .skill-list-item {
            padding: 8px;
            border: 1px solid #ddd;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: grab;
            background: white;
            user-select: none;
        }
        .skill-list-item .meta {
            margin-top: 4px;
            font-size: 11px;
            color: #666;
        }
        .skill-list-item .pill {
            display: inline-block;
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid #eee;
            background: #f7f7f7;
            margin-left: 6px;
        }
        .skill-list-item .pill.unplaced {
            border-color: #ffcc80;
            background: #fff3e0;
            color: #a66300;
        }
        .skill-list-item:hover {
            background-color: #f0f8ff;
            border-color: #b0d4ff;
        }

        /* C. Canvas Workspace (Center) */
        #canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden; /* Canvas pans inside here */
            background: #fff;
            cursor: grab;
        }
        #canvas-wrapper:active {
            cursor: grabbing;
        }

        /* The movable container for Pan/Zoom */
        #canvas-transform-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 5000px; /* Virtual Size */
            height: 5000px;
            transform-origin: 0 0;
        }

        /* Layer 1: Grid (Background) */
        #grid-layer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }

        /* Layer 2: Connections (SVG) */
        #connection-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: visibleStroke; /* Only interact with lines */
            z-index: 1;
        }
        .connection-line {
            fill: none;
            stroke: #666;
            stroke-width: 2;
            cursor: pointer;
        }
        .connection-line:hover {
            stroke: #ff9900;
            stroke-width: 4;
        }
        .connection-arrow {
            fill: #666;
        }

        /* Layer 3: Nodes (DOM) */
        #node-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through empty space */
            z-index: 2;
        }

        .skill-node {
            position: absolute;
            width: 72px; /* 90% of 80px */
            height: 72px;
            background: white;
            border: 4px solid #333; /* Thicker border */
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            pointer-events: auto; /* Enable interaction on nodes */
            cursor: move;
            transition: box-shadow 0.2s, transform 0.1s;
        }
        .skill-node.selected {
            border-color: #ff9900;
            box-shadow: 0 0 0 4px rgba(255, 153, 0, 0.3);
            z-index: 10;
        }
        /* Rarity Borders */
        .rarity-common { border-color: #9e9e9e; }
        .rarity-uncommon { border-color: #4caf50; }
        .rarity-rare { border-color: #2196f3; }
        .rarity-epic { border-color: #9c27b0; }
        .rarity-legendary { border-color: #ffc107; }

        /* Anchors */
        .node-anchor {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #fff;
            border: 2px solid #555;
            border-radius: 50%;
            z-index: 11;
            opacity: 0; 
            transition: opacity 0.2s;
            cursor: crosshair;
        }
        .skill-node:hover .node-anchor { opacity: 1; }
        
        .anchor-top { top: -6px; left: 50%; transform: translateX(-50%); }
        .anchor-bottom { bottom: -6px; left: 50%; transform: translateX(-50%); }
        .anchor-left { left: -6px; top: 50%; transform: translateY(-50%); }
        .anchor-right { right: -6px; top: 50%; transform: translateY(-50%); }

        /* D. Properties Panel (Right Sidebar) */
        #properties-panel {
            width: 420px;
            background: var(--panel-bg);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 90;
            overflow: hidden;
        }
        .panel-title {
            padding: 10px;
            font-weight: 800;
            background: #eee;
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .panel-scroll {
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
        }
        .panel {
            background: var(--panel-bg);
            border: 1px solid #e6e6e6;
            border-radius: 8px;
            padding: 12px;
        }
        .panel .panel-h {
            font-weight: 800;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .small { font-size: 12px; color: #666; }
        .badge { display:inline-block; padding:2px 6px; border-radius:999px; font-size:12px; background:#eef; margin-right:6px; }
        .input, .select, .textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
        }
        .textarea { min-height: 80px; resize: vertical; font-family: var(--monospace); font-size: 12px; }
        .grid2 {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 8px 10px;
            align-items: center;
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .table th, .table td {
            border-bottom: 1px solid #eee;
            padding: 6px 4px;
            text-align: left;
            vertical-align: top;
        }
        .table th { color: #666; font-weight: 800; }
        .row-actions { display:flex; gap:6px; }
        .error { color: var(--danger-color); font-size: 12px; }

        /* Effects editor */
        .effect-row {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 10px;
            background: #fff;
            margin-bottom: 10px;
        }
        .effect-row-head {
            display:flex;
            align-items:center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 8px;
        }
        .effect-grid {
            display:grid;
            grid-template-columns: 120px 1fr;
            gap: 8px 10px;
            align-items: center;
        }
        .effect-inline {
            display:flex;
            gap: 8px;
            align-items:center;
        }

        /* Utility */
        .debug-info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 5px 10px;
            font-size: 10px;
            pointer-events: none;
        }

    </style>
</head>
<body>

<div id="app">
    <!-- A. Toolbar -->
    <div id="toolbar">
        <input type="file" id="file-input" accept=".json" style="display: none;" onchange="editor.importJsonFile(this)">
        <button class="btn btn-dark" onclick="editor.loadProjectData()">Load Project Data</button>
        <button class="btn btn-dark" onclick="editor.toggleSkillDrawer()">Skills</button>
        <button class="btn btn-primary" onclick="document.getElementById('file-input').click()">Import skills (v1/v3)</button>
        <button class="btn btn-primary" onclick="editor.createNewSkill()">+ New Skill</button>
        <button class="btn btn-success" onclick="editor.exportJson(true)">Export (dev)
        </button>
        <button class="btn btn-success" onclick="editor.exportJson(false)">Export (runtime)
        </button>
        <button class="btn btn-danger" onclick="editor.clearCanvas()">Clear</button>
        <span style="flex:1"></span>
        <button class="btn btn-dark" onclick="editor.autoLayout()">Auto Layout</button>
    </div>

    <div id="main-container">
        <!-- B. Skill List Drawer (default collapsed) -->
        <div id="skill-drawer-handle" title="Skills"></div>
        <div id="skill-drawer" aria-label="Skill Drawer">
            <div class="panel-header" style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <span>技能库</span>
                <button class="btn btn-sm btn-dark" type="button" onclick="editor.toggleSkillDrawer(false)">Close</button>
            </div>
            <div id="skill-drawer-search">
                <input id="skill-search-input" type="text" placeholder="搜索技能：name / id" autocomplete="off" />
                <div class="small" style="margin-top:6px; color:#888;">快捷键：Ctrl+B 展开/收起，Ctrl+K 聚焦搜索</div>
            </div>
            <div id="skill-drawer-content">
                <!-- Library items will be injected here -->
            </div>
        </div>

        <!-- C. Canvas Workspace -->
        <div id="canvas-wrapper">
            <div id="canvas-transform-layer">
                <!-- Layer 1: Grid -->
                <canvas id="grid-layer" width="5000" height="5000"></canvas>
                <!-- Layer 2: Connections -->
                <svg id="connection-layer">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                          <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
                        </marker>
                    </defs>
                    <!-- Lines will be injected here -->
                </svg>
                <!-- Layer 3: Nodes -->
                <div id="node-layer">
                    <!-- Nodes will be injected here -->
                </div>
            </div>
            <div class="debug-info">平移: 拖拽空白处 | 缩放: 滚轮</div>
        </div>

        <!-- D. Properties Panel -->
        <div id="properties-panel">
            <div class="panel-title">
                <div>Skill Properties</div>
                <div class="small" id="prop-validate-summary">No selection</div>
            </div>
            <div class="panel-scroll" id="prop-content">
                <div class="panel">
                    <div class="panel-h">
                        <span>Summary</span>
                        <span id="prop-summary-badge" class="badge">—</span>
                    </div>
                    <div class="small" id="prop-summary-text">Select a node to edit...</div>
                    <div style="margin-top:10px; display:flex; gap:8px;">
                        <button class="btn btn-primary" style="flex:1" onclick="editor.duplicateCurrentNode()" id="btn-dup" disabled>Duplicate</button>
                        <button class="btn btn-danger" style="flex:1" onclick="editor.deleteCurrentNode()" id="btn-del" disabled>Delete</button>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-h">A. Basic</div>
                    <div class="grid2">
                        <div class="small">id</div>
                        <input class="input" type="text" id="prop-id" readonly>

                        <div class="small">name</div>
                        <input class="input" type="text" id="prop-name">

                        <div class="small">rarity</div>
                        <select class="select" id="prop-rarity">
                            <option value="Common">Common</option>
                            <option value="Uncommon">Uncommon</option>
                            <option value="Rare">Rare</option>
                            <option value="Epic">Epic</option>
                            <option value="Legendary">Legendary</option>
                        </select>
                    </div>
                    <div style="margin-top:10px;">
                        <div class="small" style="margin-bottom:6px;">description</div>
                        <textarea class="textarea" id="prop-desc"></textarea>
                    </div>
                    <div class="error" id="err-id" style="display:none; margin-top:8px;"></div>
                </div>

                <div class="panel">
                    <div class="panel-h">B. Tree (Editor Meta)</div>
                    <div class="grid2">
                        <div class="small">editorMeta.x</div>
                        <input class="input" type="number" id="meta-x" readonly>

                        <div class="small">editorMeta.y</div>
                        <input class="input" type="number" id="meta-y" readonly>

                        <div class="small">editorMeta.group</div>
                        <input class="input" type="text" id="meta-group" placeholder="e.g. melee" disabled>

                        <div class="small">editorMeta.locked</div>
                        <select class="select" id="meta-locked" disabled>
                            <option value="false">false</option>
                            <option value="true">true</option>
                        </select>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-h">C. Prerequisites</div>
                    <div class="small" id="prop-prerequisites">—</div>
                </div>

                <div class="panel">
                    <div class="panel-h">D. Unlock (JSON)</div>
                    <div class="small" style="margin-bottom:6px;">`unlock` 推荐结构化编辑；MVP 使用 JSON。</div>
                    <textarea class="textarea" id="prop-unlock" placeholder="{\n  \"cost\": { \"kp\": 1 },\n  \"requirements\": {},\n  \"exclusives\": [],\n  \"grants\": { \"type\": \"permanent\" }\n}"></textarea>
                    <div class="error" id="err-unlock" style="display:none; margin-top:8px;"></div>
                </div>

                <div class="panel">
                    <div class="panel-h">E. Target & Speed</div>
                    <div class="grid2">
                        <div class="small">speed</div>
                        <input class="input" type="number" id="prop-speed">

                        <div class="small">target.subject</div>
                        <select class="select" id="prop-target-subject"></select>

                        <div class="small">target.scope</div>
                        <select class="select" id="prop-target-scope"></select>

                        <div class="small">selection.mode</div>
                        <select class="select" id="prop-target-mode"></select>

                        <div class="small">selection.selectCount</div>
                        <input class="input" type="number" id="prop-target-selectCount" min="1">

                        <div class="small">candidateParts</div>
                        <div style="position:relative;">
                            <button type="button" class="btn btn-dark btn-sm" id="candidatePartsBtn" style="width:100%; text-align:left;">(none)</button>
                            <div id="candidatePartsDropdown" class="panel" style="position:absolute; top:36px; left:0; right:0; z-index:999; display:none; padding:10px;">
                                <div class="small" style="margin-bottom:8px;">选择候选部位（candidateParts）</div>
                                <div id="candidatePartsList"></div>
                                <div style="margin-top:10px; display:flex; gap:8px;">
                                    <button type="button" class="btn btn-sm btn-dark" id="candidatePartsAll">All</button>
                                    <button type="button" class="btn btn-sm btn-dark" id="candidatePartsNone">None</button>
                                    <span style="flex:1"></span>
                                    <button type="button" class="btn btn-sm btn-primary" id="candidatePartsClose">OK</button>
                                </div>
                            </div>
                        </div>

                        <div class="small">selectedParts</div>
                        <div style="position:relative;">
                            <button type="button" class="btn btn-dark btn-sm" id="selectedPartsBtn" style="width:100%; text-align:left;">(none)</button>
                            <div id="selectedPartsDropdown" class="panel" style="position:absolute; top:36px; left:0; right:0; z-index:999; display:none; padding:10px;">
                                <div class="small" style="margin-bottom:8px;">选择已选部位（selectedParts）</div>
                                <div id="selectedPartsList"></div>
                                <div style="margin-top:10px; display:flex; gap:8px;">
                                    <button type="button" class="btn btn-sm btn-dark" id="selectedPartsAll">All</button>
                                    <button type="button" class="btn btn-sm btn-dark" id="selectedPartsNone">None</button>
                                    <span style="flex:1"></span>
                                    <button type="button" class="btn btn-sm btn-primary" id="selectedPartsClose">OK</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="error" id="err-target" style="display:none; margin-top:8px;"></div>
                </div>

                <div class="panel">
                    <div class="panel-h">F. Costs</div>
                    <div class="grid2">
                        <div class="small">costs.ap</div>
                        <input class="input" type="number" id="prop-costs-ap" min="0">

                        <div class="small">costs.perTurnLimit</div>
                        <input class="input" type="number" id="prop-costs-perTurnLimit" min="1">

                        <div class="small">costs.partSlot.part</div>
                        <select class="select" id="prop-costs-part"></select>

                        <div class="small">costs.partSlot.slotCost</div>
                        <input class="input" type="number" id="prop-costs-slotCost" min="0">
                    </div>
                    <div class="error" id="err-costs" style="display:none; margin-top:8px;"></div>
                </div>

                <div class="panel">
                    <div class="panel-h">G. Requirements (JSON)</div>
                    <div class="small" style="margin-bottom:6px;">`requirements` 前期使用 JSON（后续可表单化）。</div>
                    <textarea class="textarea" id="prop-requirements" placeholder="{}"></textarea>
                    <div class="error" id="err-req" style="display:none; margin-top:8px;"></div>
                </div>

                <div class="panel">
                    <div class="panel-h">
                        <span>H. Effects</span>
                        <div class="row-actions">
                            <button class="btn btn-sm btn-dark" type="button" onclick="editor.addEffectRow()" id="btn-add-effect" disabled>+ Effect</button>
                            <button class="btn btn-sm btn-dark" type="button" onclick="editor.openEffectsJsonSync()" id="btn-open-effects-json" disabled>JSON</button>
                        </div>
                    </div>
                    <div class="small" style="margin-bottom:10px;">
                        结构化编辑（推荐）：`effectType/amountType/amount|scaling/subjectOverride/note`。高级字段可用 JSON。
                    </div>

                    <div id="effects-editor" class="panel" style="padding:10px; background:#fafafa;">
                        <div id="effects-list" class="small" style="color:#888;">(no effects)</div>
                    </div>

                    <div id="effects-json-wrap" class="panel" style="margin-top:10px; display:none; padding:10px;">
                        <div class="small" style="margin-bottom:6px;">高级 JSON（整段 effects[]），用于编辑扩展字段。点击 Apply 后才会写回。</div>
                        <textarea class="textarea" id="prop-effects" placeholder="[]"></textarea>
                        <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
                            <button class="btn btn-dark btn-sm" type="button" onclick="editor.applyEffectsJsonToForm()" id="btn-apply-effects-json" disabled>Apply JSON</button>
                            <button class="btn btn-dark btn-sm" type="button" onclick="editor.closeEffectsJsonSync()" id="btn-close-effects-json" disabled>Close</button>
                            <span style="flex:1"></span>
                            <button class="btn btn-primary btn-sm" type="button" onclick="editor.validateEffectsFromForm()" id="btn-validate-effects" disabled>Validate</button>
                        </div>
                    </div>

                    <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
                        <button class="btn btn-dark btn-sm" type="button" onclick="editor.saveEffectsFromForm()" id="btn-save-effects" disabled>Save Effects</button>
                        <div class="small" id="effects-save-hint" style="color:#888;">effects 采用显式保存（避免中间态破坏数据）</div>
                    </div>
                    <div class="error" id="err-effects" style="display:none; margin-top:8px;"></div>
                </div>

                <div class="panel">
                    <div class="panel-h">
                        <span>I. Buff Refs</span>
                        <button class="btn btn-sm btn-dark" onclick="editor.addBuffRefRow('apply')" id="btn-add-apply" disabled>+ apply</button>
                    </div>
                    <div class="small" style="margin-bottom:8px;">编辑 `buffRefs.apply/applySelf/remove`。buffId 从 `buffs.json` 下拉选择。</div>

                    <div class="small" style="font-weight:700; margin:8px 0 4px;">apply (enemy)</div>
                    <table class="table" id="table-apply">
                        <thead>
                            <tr>
                                <th>buffId</th><th>target</th><th>chance</th><th>duration</th><th>stacks</th><th></th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>

                    <div class="small" style="font-weight:700; margin:12px 0 4px;">applySelf (self)</div>
                    <button class="btn btn-sm btn-dark" onclick="editor.addBuffRefRow('applySelf')" id="btn-add-applySelf" disabled>+ applySelf</button>
                    <table class="table" id="table-applySelf" style="margin-top:6px;">
                        <thead>
                            <tr>
                                <th>buffId</th><th>target</th><th>chance</th><th>duration</th><th>stacks</th><th></th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>

                    <div class="small" style="font-weight:700; margin:12px 0 4px;">remove</div>
                    <button class="btn btn-sm btn-dark" onclick="editor.addBuffRefRow('remove')" id="btn-add-remove" disabled>+ remove</button>
                    <table class="table" id="table-remove" style="margin-top:6px;">
                        <thead>
                            <tr>
                                <th>buffId</th><th>target</th><th></th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                    <div class="error" id="err-buffs" style="display:none; margin-top:8px;"></div>
                </div>

                <div class="panel">
                    <div class="panel-h">J. Tags</div>
                    <div class="small" style="margin-bottom:6px;">`tags[]` 与 `tagMeta`（用于平衡统计与校验）。</div>
                    <textarea class="textarea" id="prop-tags" placeholder="[]"></textarea>
                    <div class="small" style="margin:10px 0 6px;">tagMeta (JSON)</div>
                    <textarea class="textarea" id="prop-tagMeta" placeholder="{}"></textarea>
                    <div class="error" id="err-tags" style="display:none; margin-top:8px;"></div>
                </div>

                <div class="panel">
                    <button class="btn btn-success" style="width:100%;" onclick="editor.saveCurrentNode()" id="btn-save" disabled>Save Changes</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>

/**
 * Skill Editor Logic
 * Implements Layered Rendering & Grid System
 */
class SkillEditor {
    constructor() {
        // Constants
        this.GRID_SIZE = 100;
        this.NODE_SIZE = 72;
        this.NODE_HALF = this.NODE_SIZE / 2;
        this.CONNECTION_MARGIN = 12;
        this.ANCHOR_HYSTERESIS_PX = 14;
        this.CANVAS_WIDTH = 5000;
        this.CANVAS_HEIGHT = 5000;

        // State
        this.skills = []; // Array of skill objects (editor internal)
        this.buffDict = {}; // buffs.json map
        this.skillPackMeta = null; // skills_melee_v3.json meta
        this.skillPackSchemaVersion = null;
        this.defaultParts = ['head','chest','left_arm','right_arm','left_leg','right_leg'];
        this.enums = {
            rarities: ['Common','Uncommon','Rare','Epic','Legendary'],
            targetSubjects: ['SUBJECT_SELF','SUBJECT_ENEMY','SUBJECT_BOTH'],
            targetScopes: ['SCOPE_ENTITY','SCOPE_PART','SCOPE_MULTI_PARTS'],
            selectionModes: ['single','multiple','random_single','random_multiple'],
            effectTypes: ['DMG_HP','DMG_ARMOR','PIERCE','HEAL','ARMOR_ADD','AP_GAIN','SPEED','BUFF_APPLY','BUFF_REMOVE'],
            amountTypes: ['ABS','PCT_MAX','PCT_CURRENT','SCALING'],
            requirementSelfPartModes: ['ANY','ALL'],
            partOverrideModes: ['fixed','listed'],
            hitModes: ['normal','cannot_dodge','always_crit']
        };
        // Selection (single + multi)
        this.selectedNodeId = null; // backward compat: primary selected
        this.selectedNodeIds = new Set();
        this.primarySelectedNodeId = null;
        this.isDragging = false;
        this.dragOffset = { x: 0, y: 0 };
        this.draggedNodeId = null;
        
        // Panning State
        this.pan = { x: 0, y: 0 };
        this.zoom = 1;
        this.isPanning = false;
        this.lastMousePos = { x: 0, y: 0 };
        
        // Connection State
        this.selectedConnection = null; // Store { source: id, target: id }
        this.isConnecting = false;
        this.connectionStartId = null;
        this.tempLine = null;

        // DOM Elements
        this.elTransformLayer = document.getElementById('canvas-transform-layer');
        this.elGridCanvas = document.getElementById('grid-layer');
        this.elNodeLayer = document.getElementById('node-layer');
        this.elSvgLayer = document.getElementById('connection-layer');
        this.elPropId = document.getElementById('prop-id');
        this.elPropName = document.getElementById('prop-name');
        this.elPropRarity = document.getElementById('prop-rarity');
        this.elPropCost = document.getElementById('prop-cost'); // legacy (may not exist)
        this.elPropSpeed = document.getElementById('prop-speed');
        this.elPropTargetType = document.getElementById('prop-targetType'); // legacy (may not exist)
        this.elPropRequiredPart = document.getElementById('prop-requiredPart'); // legacy (may not exist)
        // targetParts dropdown
        this.elTargetPartsBtn = document.getElementById('targetPartsBtn'); // legacy (may not exist)
        this.elTargetPartsDropdown = document.getElementById('targetPartsDropdown'); // legacy (may not exist)
        this.elPropType = document.getElementById('prop-type'); // legacy (may not exist)
        this.elPropValue = document.getElementById('prop-value'); // legacy (may not exist)
        this.elPropValueType = document.getElementById('prop-valueType'); // legacy (may not exist)
        this.elPropDesc = document.getElementById('prop-desc');
        this.elPropEffects = document.getElementById('prop-effects');
        this.elEffectsEditor = document.getElementById('effects-editor');
        this.elEffectsList = document.getElementById('effects-list');
        this.elEffectsJsonWrap = document.getElementById('effects-json-wrap');
        this.elBtnAddEffect = document.getElementById('btn-add-effect');
        this.elBtnOpenEffectsJson = document.getElementById('btn-open-effects-json');
        this.elBtnApplyEffectsJson = document.getElementById('btn-apply-effects-json');
        this.elBtnCloseEffectsJson = document.getElementById('btn-close-effects-json');
        this.elBtnValidateEffects = document.getElementById('btn-validate-effects');
        this.elPrereqText = document.getElementById('prop-prerequisites');
        this.elMetaX = document.getElementById('meta-x');
        this.elMetaY = document.getElementById('meta-y');

        // v3 panel fields
        this.elTargetSubject = document.getElementById('prop-target-subject');
        this.elTargetScope = document.getElementById('prop-target-scope');
        this.elSelectionMode = document.getElementById('prop-target-mode');
        this.elSelectionSelectCount = document.getElementById('prop-target-selectCount');
        this.elCostsAp = document.getElementById('prop-costs-ap');
        this.elCostsPerTurnLimit = document.getElementById('prop-costs-perTurnLimit');
        this.elCostsPart = document.getElementById('prop-costs-part');
        this.elCostsSlotCost = document.getElementById('prop-costs-slotCost');
        this.elUnlock = document.getElementById('prop-unlock');
        this.elRequirements = document.getElementById('prop-requirements');
        this.elTags = document.getElementById('prop-tags');
        this.elTagMeta = document.getElementById('prop-tagMeta');
        this.elErrUnlock = document.getElementById('err-unlock');
        this.elErrCosts = document.getElementById('err-costs');
        this.elErrReq = document.getElementById('err-req');
        this.elErrTags = document.getElementById('err-tags');

        this.elErrId = document.getElementById('err-id');
        this.elErrTarget = document.getElementById('err-target');
        this.elErrBuffs = document.getElementById('err-buffs');
        this.elErrEffects = document.getElementById('err-effects');
        this.elValidateSummary = document.getElementById('prop-validate-summary');
        this.elSummaryText = document.getElementById('prop-summary-text');
        this.elSummaryBadge = document.getElementById('prop-summary-badge');

        // Skill Drawer
        this.elSkillDrawer = document.getElementById('skill-drawer');
        this.elSkillDrawerHandle = document.getElementById('skill-drawer-handle');
        this.elSkillDrawerContent = document.getElementById('skill-drawer-content');
        this.elSkillSearchInput = document.getElementById('skill-search-input');

        // Initialize
        this.initGrid();
        this.attachEvents();

        this.initSkillDrawer();
        
        // Seed minimal nodes
        this.addSkillNode({
            id: 'skill_slash', name: '斩击', rarity: 'Common', cost: 2, speed: 0,
            targetType: 'SINGLE_PART',
            description: '基础的挥砍攻击。',
            prerequisites: [],
            buffRefs: { apply: [], applySelf: [], remove: [] },
            effects: [],
            editorMeta: { x: 100, y: 100 }
        });

        // Apply meta-driven UI defaults (even before loading pack)
        this.applyMetaToUI();

        // v3 selection (candidateParts/selectedParts) dropdown interactions
        this.elCandidatePartsBtn = document.getElementById('candidatePartsBtn');
        this.elCandidatePartsDropdown = document.getElementById('candidatePartsDropdown');
        this.elCandidatePartsList = document.getElementById('candidatePartsList');
        this.elSelectedPartsBtn = document.getElementById('selectedPartsBtn');
        this.elSelectedPartsDropdown = document.getElementById('selectedPartsDropdown');
        this.elSelectedPartsList = document.getElementById('selectedPartsList');

        const bindDropdown = (btn, dropdown, closeId, allId, noneId, onClose) => {
            if (!btn || !dropdown) return;
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropdown.style.display = (dropdown.style.display === 'none' || !dropdown.style.display) ? 'block' : 'none';
            });
            const closeBtn = document.getElementById(closeId);
            closeBtn?.addEventListener('click', (e) => {
                e.preventDefault();
                dropdown.style.display = 'none';
                onClose?.();
            });
            document.getElementById(allId)?.addEventListener('click', (e) => {
                e.preventDefault();
                onClose?.({ action: 'all' });
            });
            document.getElementById(noneId)?.addEventListener('click', (e) => {
                e.preventDefault();
                onClose?.({ action: 'none' });
            });

            window.addEventListener('mousedown', (e) => {
                if (dropdown.style.display !== 'block') return;
                const inside = dropdown.contains(e.target) || btn.contains(e.target);
                if (!inside) {
                    dropdown.style.display = 'none';
                    onClose?.();
                }
            });

            dropdown.addEventListener('change', () => onClose?.({ action: 'change' }));
        };

        bindDropdown(this.elCandidatePartsBtn, this.elCandidatePartsDropdown, 'candidatePartsClose', 'candidatePartsAll', 'candidatePartsNone', () => {
            this.updateCandidatePartsBtnText?.();
        });
        bindDropdown(this.elSelectedPartsBtn, this.elSelectedPartsDropdown, 'selectedPartsClose', 'selectedPartsAll', 'selectedPartsNone', () => {
            this.updateSelectedPartsBtnText?.();
        });
    }

    // --- Meta / Schema helpers (v3 pack focused; see design/skill_editor_design.md 2.3) ---

    setSkillPackMeta(meta, schemaVersion) {
        this.skillPackMeta = meta || null;
        this.skillPackSchemaVersion = schemaVersion || null;

        if (meta?.defaultParts && Array.isArray(meta.defaultParts)) {
            this.defaultParts = meta.defaultParts.slice();
        }
        if (meta?.enums && typeof meta.enums === 'object') {
            const e = meta.enums;
            ['rarities','targetSubjects','targetScopes','selectionModes','effectTypes','amountTypes','requirementSelfPartModes','partOverrideModes','hitModes'].forEach((k) => {
                if (Array.isArray(e[k])) this.enums[k] = e[k].slice();
            });
        }

        this.applyMetaToUI();
    }

    applyMetaToUI() {
        // 1) rarity dropdown
        if (this.elPropRarity && Array.isArray(this.enums?.rarities)) {
            this.elPropRarity.innerHTML = this.enums.rarities.map(r => `<option value="${r}">${r}</option>`).join('');
        }

        // 1.1) v3 target enums
        if (this.elTargetSubject && Array.isArray(this.enums?.targetSubjects)) {
            this.elTargetSubject.innerHTML = this.enums.targetSubjects.map(v => `<option value="${v}">${v}</option>`).join('');
        }
        if (this.elTargetScope && Array.isArray(this.enums?.targetScopes)) {
            this.elTargetScope.innerHTML = this.enums.targetScopes.map(v => `<option value="${v}">${v}</option>`).join('');
        }
        if (this.elSelectionMode && Array.isArray(this.enums?.selectionModes)) {
            this.elSelectionMode.innerHTML = this.enums.selectionModes.map(v => `<option value="${v}">${v}</option>`).join('');
        }

        // 1.2) costs.partSlot.part dropdown driven by meta.defaultParts
        if (this.elCostsPart && Array.isArray(this.defaultParts)) {
            const opts = ['<option value="">(none)</option>']
                .concat(this.defaultParts.map(p => `<option value="${p}">${p}</option>`));
            this.elCostsPart.innerHTML = opts.join('');
        }

        // 2) requiredPart dropdown (legacy UI) driven by meta.defaultParts
        if (this.elPropRequiredPart && Array.isArray(this.defaultParts)) {
            const opts = ['<option value="">(none)</option>']
                .concat(this.defaultParts.map(p => `<option value="${p}">${p}</option>`));
            this.elPropRequiredPart.innerHTML = opts.join('');
        }

        // 3) targetParts dropdown checkboxes driven by meta.defaultParts
        if (this.elTargetPartsDropdown && Array.isArray(this.defaultParts)) {
            const box = this.elTargetPartsDropdown;
            const existing = Array.from(box.querySelectorAll('label')).filter(l => l.querySelector('input[type="checkbox"]'));
            existing.forEach(l => l.remove());
            const buttonsRow = box.querySelector('div[style*="margin-top:10px"]');
            this.defaultParts.forEach((p) => {
                const label = document.createElement('label');
                label.className = 'small';
                label.style.display = 'flex';
                label.style.gap = '8px';
                label.style.alignItems = 'center';
                label.innerHTML = `<input type="checkbox" value="${p}">${p}`;
                if (buttonsRow) box.insertBefore(label, buttonsRow);
                else box.appendChild(label);
            });
        }

        // 4) v3 candidateParts / selectedParts checkbox lists driven by meta.defaultParts
        const ensurePartsList = (container) => {
            if (!container || !Array.isArray(this.defaultParts)) return;
            container.innerHTML = '';
            this.defaultParts.forEach((p) => {
                const label = document.createElement('label');
                label.className = 'small';
                label.style.display = 'flex';
                label.style.gap = '8px';
                label.style.alignItems = 'center';
                label.innerHTML = `<input type="checkbox" value="${p}">${p}`;
                container.appendChild(label);
            });
        };
        ensurePartsList(this.elCandidatePartsList);
        ensurePartsList(this.elSelectedPartsList);
    }

    // v3 -> editor (legacy-friendly view)
    fromV3Skill(v3) {
        const skill = JSON.parse(JSON.stringify(v3 || {}));

        // v3 editorMeta is in grid coords; editor uses pixel coords. Accept both.
        if (skill.editorMeta && typeof skill.editorMeta.x === 'number' && typeof skill.editorMeta.y === 'number') {
            // v3 pack 约定：skills_melee_v3.json 的 editorMeta.x/y 为“网格坐标”。
            // 导入到编辑器时需要转换为画布像素坐标（node top-left）。
            // 注意：对象展开必须放在前面，避免覆盖计算出的 x/y。
            const gx = skill.editorMeta.x;
            const gy = skill.editorMeta.y;
            const px = gx * this.GRID_SIZE + 14;
            const py = gy * this.GRID_SIZE + 14;
            skill.editorMeta = { ...skill.editorMeta, x: px, y: py };
        }

        // costs.ap -> legacy cost
        if (skill.costs && typeof skill.costs.ap === 'number') {
            skill.cost = skill.costs.ap;
        } else if (typeof skill.cost !== 'number') {
            skill.cost = 0;
        }

        // target (v3) -> legacy targetType/requiredPart/targetParts (for current UI)
        const target = skill.target || {};
        const subject = target.subject;
        const scope = target.scope;
        const selMode = target.selection?.mode;
        const selectedParts = Array.isArray(target.selection?.selectedParts) ? target.selection.selectedParts : [];
        const candidateParts = Array.isArray(target.selection?.candidateParts) ? target.selection.candidateParts : [];

        let targetType = 'SINGLE_PART';
        if (subject === 'SUBJECT_SELF' && scope === 'SCOPE_ENTITY') targetType = 'SELF';
        else if (subject === 'SUBJECT_ENEMY' && scope === 'SCOPE_ENTITY') targetType = 'ENEMY';
        else if (subject === 'SUBJECT_SELF' && scope === 'SCOPE_MULTI_PARTS') targetType = 'SELF_PARTS';
        else if (subject === 'SUBJECT_ENEMY' && scope === 'SCOPE_MULTI_PARTS') targetType = 'ALL_PARTS';
        else if (scope === 'SCOPE_PART') {
            if (selMode === 'random_single' || selMode === 'random_multiple') targetType = 'RANDOM_PART';
            else targetType = 'SINGLE_PART';
        }
        skill.targetType = targetType;

        if (skill.targetType === 'SINGLE_PART') {
            const fixed = selectedParts.length === 1 ? selectedParts[0] : (candidateParts.length === 1 ? candidateParts[0] : undefined);
            if (fixed) skill.requiredPart = fixed;
        }
        if (skill.targetType === 'SELF_PARTS') {
            skill.targetParts = selectedParts.length ? selectedParts.slice() : candidateParts.slice();
        }

        // prerequisites
        if (!Array.isArray(skill.prerequisites)) skill.prerequisites = [];

        // buffRefs
        if (!skill.buffRefs) skill.buffRefs = { apply: [], applySelf: [], remove: [] };
        if (!skill.buffRefs.apply) skill.buffRefs.apply = [];
        if (!skill.buffRefs.applySelf) skill.buffRefs.applySelf = [];
        if (!skill.buffRefs.remove) skill.buffRefs.remove = [];

        // effects
        if (!Array.isArray(skill.effects)) skill.effects = [];

        return skill;
    }

    // editor -> v3 (pack schema output)
    toV3Skill(legacy) {
        const s = JSON.parse(JSON.stringify(legacy || {}));

        const targetType = s.targetType || 'SINGLE_PART';
        const requiredPart = s.requiredPart;
        const targetParts = Array.isArray(s.targetParts) ? s.targetParts : [];

        let subject = 'SUBJECT_ENEMY';
        let scope = 'SCOPE_PART';
        let selection = {
            mode: 'single',
            candidateParts: (this.defaultParts || []).slice(),
            selectedParts: [],
            selectCount: 1,
        };

        if (targetType === 'SELF') {
            subject = 'SUBJECT_SELF';
            scope = 'SCOPE_ENTITY';
            selection.mode = 'multiple';
            selection.candidateParts = (this.defaultParts || []).slice();
            selection.selectedParts = selection.candidateParts.slice();
            selection.selectCount = selection.selectedParts.length;
        } else if (targetType === 'ENEMY') {
            subject = 'SUBJECT_ENEMY';
            scope = 'SCOPE_ENTITY';
            selection.mode = 'multiple';
            selection.candidateParts = (this.defaultParts || []).slice();
            selection.selectedParts = selection.candidateParts.slice();
            selection.selectCount = selection.selectedParts.length;
        } else if (targetType === 'SELF_PARTS') {
            subject = 'SUBJECT_SELF';
            scope = 'SCOPE_MULTI_PARTS';
            selection.mode = 'multiple';
            selection.candidateParts = (this.defaultParts || []).slice();
            selection.selectedParts = targetParts.length ? targetParts.slice() : selection.candidateParts.slice();
            selection.selectCount = selection.selectedParts.length;
        } else if (targetType === 'ALL_PARTS') {
            subject = 'SUBJECT_ENEMY';
            scope = 'SCOPE_MULTI_PARTS';
            selection.mode = 'multiple';
            selection.candidateParts = (this.defaultParts || []).slice();
            selection.selectedParts = selection.candidateParts.slice();
            selection.selectCount = selection.selectedParts.length;
        } else if (targetType === 'RANDOM_PART') {
            subject = 'SUBJECT_ENEMY';
            scope = 'SCOPE_PART';
            selection.mode = 'random_single';
            selection.candidateParts = (this.defaultParts || []).slice();
            selection.selectedParts = [];
            selection.selectCount = 1;
        } else {
            // SINGLE_PART
            subject = 'SUBJECT_ENEMY';
            scope = 'SCOPE_PART';
            selection.mode = 'single';
            selection.selectedParts = requiredPart ? [requiredPart] : [];
            selection.candidateParts = requiredPart ? [requiredPart] : (this.defaultParts || []).slice();
            selection.selectCount = 1;
        }

        // Convert editorMeta pixel coords -> v3 grid coords (to match skills_melee_v3.json style)
        let editorMeta = s.editorMeta;
        if (editorMeta && typeof editorMeta.x === 'number' && typeof editorMeta.y === 'number') {
            const gx = Math.round((editorMeta.x - 14) / this.GRID_SIZE);
            const gy = Math.round((editorMeta.y - 14) / this.GRID_SIZE);
            editorMeta = { ...editorMeta, x: gx, y: gy };
        }

        return {
            id: s.id,
            name: s.name,
            rarity: s.rarity || 'Common',
            description: s.description || '',
            prerequisites: Array.isArray(s.prerequisites) ? s.prerequisites.slice() : [],
            unlock: s.unlock || { cost: { kp: 1 }, requirements: {}, exclusives: [], grants: { type: 'permanent' } },
            editorMeta: editorMeta || { x: 0, y: 0, group: 'melee', locked: false },
            speed: Number(s.speed || 0),
            target: { subject, scope, selection },
            requirements: s.requirements || {},
            costs: {
                ap: Number(s.cost ?? 0),
                ...(s.costs && typeof s.costs === 'object' ? s.costs : {}),
                perTurnLimit: (s.costs?.perTurnLimit ?? 1)
            },
            effects: Array.isArray(s.effects) ? s.effects : [],
            buffRefs: s.buffRefs || { apply: [], applySelf: [], remove: [] },
            tags: Array.isArray(s.tags) ? s.tags : []
        };
    }

    initSkillDrawer() {
        if (this.elSkillDrawerHandle) {
            this.elSkillDrawerHandle.addEventListener('click', () => this.toggleSkillDrawer());
        }
        if (this.elSkillSearchInput) {
            this.elSkillSearchInput.addEventListener('input', () => this.renderSkillLibrary());
            this.elSkillSearchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    this.elSkillSearchInput.value = '';
                    this.renderSkillLibrary();
                    this.toggleSkillDrawer(false);
                }
            });
        }

        window.addEventListener('keydown', (e) => {
            const key = (e.key || '').toLowerCase();
            if (e.ctrlKey && key === 'b') {
                e.preventDefault();
                this.toggleSkillDrawer();
            }
            if (e.ctrlKey && key === 'k') {
                e.preventDefault();
                this.toggleSkillDrawer(true);
                this.elSkillSearchInput?.focus();
            }
        });

        // Default collapsed as per design
        this.toggleSkillDrawer(false);
        this.renderSkillLibrary();
    }

    toggleSkillDrawer(forceOpen) {
        if (!this.elSkillDrawer) return;
        const wantOpen = typeof forceOpen === 'boolean' ? forceOpen : !this.elSkillDrawer.classList.contains('open');
        if (wantOpen) this.elSkillDrawer.classList.add('open');
        else this.elSkillDrawer.classList.remove('open');
    }

    renderSkillLibrary() {
        if (!this.elSkillDrawerContent) return;
        const q = (this.elSkillSearchInput?.value || '').trim().toLowerCase();
        const list = this.skills
            .slice()
            .sort((a, b) => (a.name || '').localeCompare((b.name || ''), 'zh-CN'))
            .filter(s => {
                if (!q) return true;
                return (s.name || '').toLowerCase().includes(q) || (s.id || '').toLowerCase().includes(q);
            });

        this.elSkillDrawerContent.innerHTML = '';
        list.forEach(skill => {
            const el = document.createElement('div');
            el.className = 'skill-list-item';
            el.dataset.id = skill.id;
            el.draggable = true;
            const unplaced = !skill.editorMeta || typeof skill.editorMeta.x !== 'number' || typeof skill.editorMeta.y !== 'number';

            el.innerHTML = `
                <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
                    <div style="font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${skill.name || '(unnamed)'}</div>
                    ${unplaced ? '<span class="pill unplaced">未布局</span>' : ''}
                </div>
                <div class="meta">${skill.id || ''}</div>
            `;

            el.addEventListener('click', () => {
                this.selectedNodeId = skill.id;
                if (!unplaced) {
                    const wrapper = document.getElementById('canvas-wrapper');
                    const rect = wrapper.getBoundingClientRect();
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    this.pan.x = centerX - (skill.editorMeta.x + 36) * this.zoom;
                    this.pan.y = centerY - (skill.editorMeta.y + 36) * this.zoom;
                    this.updateTransform();
                }
                this.renderNodes();
                this.loadProperties(skill);
            });

            el.addEventListener('dragstart', (ev) => {
                ev.dataTransfer?.setData('text/skill-id', skill.id);
            });

            this.elSkillDrawerContent.appendChild(el);
        });
    }

    setTargetPartsSelection(parts) {
        const set = new Set(parts);
        const checks = this.elTargetPartsDropdown.querySelectorAll('input[type="checkbox"]');
        checks.forEach(cb => {
            cb.checked = set.has(cb.value);
        });
        this.updateTargetPartsBtnText();
    }

    getSelectedTargetParts() {
        const checks = this.elTargetPartsDropdown.querySelectorAll('input[type="checkbox"]');
        const parts = [];
        checks.forEach(cb => {
            if (cb.checked) parts.push(cb.value);
        });
        return parts;
    }

    updateTargetPartsBtnText() {
        const parts = this.getSelectedTargetParts();
        this.elTargetPartsBtn.textContent = parts.length ? parts.join(', ') : '(none)';
    }

    // --- A. Rendering ---

    initGrid() {
        const ctx = this.elGridCanvas.getContext('2d');
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;

        // Draw Vertical Lines
        for (let x = 0; x <= this.CANVAS_WIDTH; x += this.GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, this.CANVAS_HEIGHT);
            ctx.stroke();
        }

        // Draw Horizontal Lines
        for (let y = 0; y <= this.CANVAS_HEIGHT; y += this.GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(this.CANVAS_WIDTH, y);
            ctx.stroke();
        }
    }

    renderNodes() {
        this.elNodeLayer.innerHTML = '';
        this.skills.forEach(skill => {
            const el = document.createElement('div');
            el.className = `skill-node rarity-${skill.rarity ? skill.rarity.toLowerCase() : 'common'}`;
            if ((this.selectedNodeIds && this.selectedNodeIds.has(skill.id)) || this.selectedNodeId === skill.id) {
                el.classList.add('selected');
            }
            
            // Initial Position (Snap to Grid Center)
            // Use editorMeta if available, otherwise default
            const x = skill.editorMeta ? skill.editorMeta.x : 0;
            const y = skill.editorMeta ? skill.editorMeta.y : 0;
            
            // Center the 80x80 node in the 100x100 grid cell
            // Grid Center for (Col C, Row R) is: (C*100 + 50, R*100 + 50)
            // Node TopLeft to center: (X - 40, Y - 40)
            
            // Here we assume editorMeta stores the TOP-LEFT coordinate of the NODE
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            
            el.dataset.id = skill.id;
            el.innerHTML = `
                <div>${skill.name}</div>
                <div style="font-size:10px; color:#666">AP: ${skill.cost}</div>
                <!-- Anchors -->
                <div class="node-anchor anchor-top" data-dir="top"></div>
                <div class="node-anchor anchor-right" data-dir="right"></div>
                <div class="node-anchor anchor-bottom" data-dir="bottom"></div>
                <div class="node-anchor anchor-left" data-dir="left"></div>
            `;

            // Event for selecting/dragging
            el.addEventListener('mousedown', (e) => this.onNodeMouseDown(e, skill));

            this.elNodeLayer.appendChild(el);
        });

        this.renderConnections();
    }

    renderConnections() {
        // Clear existing lines (except defs)
        const defs = this.elSvgLayer.querySelector('defs').outerHTML;
        this.elSvgLayer.innerHTML = defs; 
        
        // Add Temp Line Group (for dragging)
        this.elTempLineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        this.elSvgLayer.appendChild(this.elTempLineGroup);

        this.skills.forEach(skill => {
            const parents = Array.isArray(skill.prerequisites) ? skill.prerequisites : [];

            parents.forEach(parentId => {
                const target = this.getSkillById(parentId);
                if (target) {
                    this.drawConnection(target, skill);
                }
            });
        });
    }

    // 辅助：获取鼠标在 Layer 中的局部坐标
    getLayerPos(clientX, clientY) {
        const rect = document.getElementById('canvas-wrapper').getBoundingClientRect();
        return {
            x: (clientX - rect.left - this.pan.x) / this.zoom,
            y: (clientY - rect.top - this.pan.y) / this.zoom
        };
    }

    drawConnection(sourceNode, targetNode) {
        // Routing Strategy (per design/skill_editor_design.md)
        // - Orthogonal polyline
        // - Visual priority: Vertical -> Horizontal -> Vertical (V-H-V)
        // - Adaptive anchors by relative Y (top/bottom)
        const sX = (sourceNode.editorMeta?.x ?? 0) + this.NODE_HALF;
        const sY = (sourceNode.editorMeta?.y ?? 0) + this.NODE_HALF;
        const tX = (targetNode.editorMeta?.x ?? 0) + this.NODE_HALF;
        const tY = (targetNode.editorMeta?.y ?? 0) + this.NODE_HALF;

        const [start, end] = this.getAdaptiveAnchors(sourceNode, targetNode);

        const margin = this.CONNECTION_MARGIN;
        const leaveY = start.dir === 'bottom' ? start.y + margin : start.y - margin;
        const enterY = end.dir === 'top' ? end.y - margin : end.y + margin;

        // Choose a mid channel between leaveY and enterY, then snap to grid line
        let midY = (leaveY + enterY) / 2;
        midY = this.snapToGridLine(midY);

        const points = [
            [start.x, start.y],
            [start.x, leaveY],
            [end.x, midY],
            [end.x, enterY],
            [end.x, end.y],
        ];

        const pathStr = points.map(p => `${p[0]},${p[1]}`).join(' ');

        const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        polyline.setAttribute('points', pathStr);
        polyline.setAttribute('class', 'connection-line');
        polyline.setAttribute('marker-end', 'url(#arrowhead)');
        
        // Check if selected
        if (this.selectedConnection && 
            this.selectedConnection.source === sourceNode.id && 
            this.selectedConnection.target === targetNode.id) {
            polyline.setAttribute('stroke', '#ff0000'); // Red for selected
            polyline.setAttribute('stroke-width', '4');
        }

        // Add Click Event to Select
        polyline.addEventListener('click', (e) => {
            e.stopPropagation();
            this.selectedConnection = { source: sourceNode.id, target: targetNode.id };
            this.clearSelection(); // Deselect nodes if line selected
            this.renderNodes(); // Re-render to show highlight
            this.renderConnections();
        });

        this.elSvgLayer.appendChild(polyline);
    }

    // --- Routing Helpers ---

    snapToGridLine(v) {
        // Align to nearest grid line for cleaner look.
        return Math.round(v / this.GRID_SIZE) * this.GRID_SIZE;
    }

    getAdaptiveAnchors(sourceNode, targetNode) {
        const s = sourceNode.editorMeta || { x: 0, y: 0 };
        const t = targetNode.editorMeta || { x: 0, y: 0 };
        const sCenterY = s.y + this.NODE_HALF;
        const tCenterY = t.y + this.NODE_HALF;

        // hysteresis: try to keep previous direction if nodes are near the boundary
        const key = `${sourceNode.id}->${targetNode.id}`;
        const prev = this._edgeAnchorCache?.get(key);
        const dy = sCenterY - tCenterY;

        let verticalDir;
        if (prev && Math.abs(dy) < this.ANCHOR_HYSTERESIS_PX) {
            verticalDir = prev;
        } else {
            verticalDir = (sCenterY <= tCenterY) ? 'down' : 'up';
        }

        if (!this._edgeAnchorCache) this._edgeAnchorCache = new Map();
        this._edgeAnchorCache.set(key, verticalDir);

        if (verticalDir === 'down') {
            return [
                { x: s.x + this.NODE_HALF, y: s.y + this.NODE_SIZE, dir: 'bottom' },
                { x: t.x + this.NODE_HALF, y: t.y, dir: 'top' },
            ];
        }

        return [
            { x: s.x + this.NODE_HALF, y: s.y, dir: 'top' },
            { x: t.x + this.NODE_HALF, y: t.y + this.NODE_SIZE, dir: 'bottom' },
        ];
    }

    // --- B. Data Management ---

    addSkillNode(skill = {}) {
        // Ensure editorMeta exists and is snapped
        if (!skill.editorMeta) {
            skill.editorMeta = { x: 14, y: 14 }; // 14 offset for 72px node in 100px grid
        }
        this.snapToGrid(skill.editorMeta);

        // v3 skill migration: if costs.ap exists, mirror to cost for legacy UI
        if (skill.costs && typeof skill.costs.ap === 'number' && typeof skill.cost !== 'number') {
            skill.cost = skill.costs.ap;
        }
        // Normalize current schema
        if (!Array.isArray(skill.prerequisites)) skill.prerequisites = [];
        if (!skill.buffRefs) skill.buffRefs = { apply: [], applySelf: [], remove: [] };
        if (!skill.buffRefs.apply) skill.buffRefs.apply = [];
        if (!skill.buffRefs.applySelf) skill.buffRefs.applySelf = [];
        if (!skill.buffRefs.remove) skill.buffRefs.remove = [];
        if (!Array.isArray(skill.effects)) skill.effects = [];

        this.skills.push(skill);
        this.renderNodes();
        this.renderSkillLibrary();
    }

    getSkillById(id) {
        return this.skills.find(s => s.id === id);
    }

    snapToGrid(pos) {
        // Grid Size 100.
        // Node is 72x72.
        // Cell Center is (X*100 + 50, Y*100 + 50).
        // Node TopLeft to center it: X*100 + 14, Y*100 + 14.
        
        const col = Math.round((pos.x - 14) / this.GRID_SIZE);
        const row = Math.round((pos.y - 14) / this.GRID_SIZE);
        
        pos.x = col * this.GRID_SIZE + 14;
        pos.y = row * this.GRID_SIZE + 14;
    }

    // --- C. Interaction & Events ---

    attachEvents() {
        const wrapper = document.getElementById('canvas-wrapper');
        
        // Panning (Right Click or Space+Drag, logic simplified to generic drag on background)
        wrapper.addEventListener('mousedown', (e) => {
            if (e.target === wrapper || e.target.id === 'connection-layer' || e.target.id === 'node-layer') {
                this.isPanning = true;
                this.selectedConnection = null; // Click background to deselect line
                this.clearSelection();
                this.renderNodes();
                this.renderConnections();

                this.lastMousePos = { x: e.clientX, y: e.clientY };
                wrapper.style.cursor = 'grabbing';
            }
        });

        window.addEventListener('mousemove', (e) => {
            // Drag Connection
            if (this.isConnecting) {
                this.updateConnectionDrag(e);
            }
            // Drag Node
            else if (this.isDragging && this.draggedNodeId) {
                const node = this.getSkillById(this.draggedNodeId);
                if (node) {
                    // Raw position updates for smooth drag
                    // We will snap on Release
                    // Convert screen delta to canvas zoom space
                    const dx = (e.clientX - this.lastMousePos.x) / this.zoom;
                    const dy = (e.clientY - this.lastMousePos.y) / this.zoom;
                    
                    // Group move: if dragging an already-selected node, move entire selection
                    if (this.selectedNodeIds && this.selectedNodeIds.size > 0 && this.selectedNodeIds.has(this.draggedNodeId)) {
                        this.skills.forEach(s => {
                            if (this.selectedNodeIds.has(s.id) && s.editorMeta) {
                                s.editorMeta.x += dx;
                                s.editorMeta.y += dy;
                            }
                        });
                    } else {
                        node.editorMeta.x += dx;
                        node.editorMeta.y += dy;
                    }
                    
                    this.lastMousePos = { x: e.clientX, y: e.clientY };
                    this.renderNodes(); // Re-render (inefficient but works for prototype)
                }
            } 
            // Pan Canvas
            else if (this.isPanning) {
                const dx = e.clientX - this.lastMousePos.x;
                const dy = e.clientY - this.lastMousePos.y;
                this.pan.x += dx;
                this.pan.y += dy;
                this.lastMousePos = { x: e.clientX, y: e.clientY };
                this.updateTransform();
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (this.isConnecting) {
                this.endConnectionDrag(e);
            }

            if (this.isDragging) {
                // Snap on Drop
                if (this.selectedNodeIds && this.selectedNodeIds.size > 0 && this.draggedNodeId && this.selectedNodeIds.has(this.draggedNodeId)) {
                    this.skills.forEach(s => {
                        if (this.selectedNodeIds.has(s.id) && s.editorMeta) {
                            this.snapToGrid(s.editorMeta);
                        }
                    });
                    this.renderNodes();
                } else {
                    const node = this.getSkillById(this.draggedNodeId);
                    if (node) {
                        this.snapToGrid(node.editorMeta);
                        this.renderNodes();
                    }
                }
                this.isDragging = false;
                this.draggedNodeId = null;
            }
            if (this.isPanning) {
                this.isPanning = false;
                wrapper.style.cursor = 'grab';
            }
        });

        // Zooming
        wrapper.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleAmount = 0.1;
            if (e.deltaY < 0) {
                this.zoom += scaleAmount;
            } else {
                this.zoom -= scaleAmount;
            }
            if (this.zoom < 0.2) this.zoom = 0.2;
            if (this.zoom > 3) this.zoom = 3;
            this.updateTransform();
        });

        // Property Inputs: autosave on blur / Enter (except JSON textarea)
        const autoSaveInputs = [
            this.elPropName,
            this.elPropCost,
            this.elPropSpeed,
            this.elPropType,
            this.elPropValue,
            this.elPropValueType,
            this.elPropDesc,
        ].filter(Boolean);

        autoSaveInputs.forEach((el) => {
            el.addEventListener('blur', () => this.saveCurrentNode());
            // Enter to save (textarea should not use Enter)
            if (el.tagName && el.tagName.toLowerCase() === 'textarea') return;
            el.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.saveCurrentNode();
                }
            });
        });

        // selects: save on change
        this.elPropRarity?.addEventListener('change', () => this.saveCurrentNode());
        this.elPropTargetType?.addEventListener('change', () => this.saveCurrentNode());
        this.elPropRequiredPart?.addEventListener('change', () => this.saveCurrentNode());

        // Global Key Events for Deletion
        window.addEventListener('keydown', (e) => {
            // 在编辑表单（input/textarea/select 或 contenteditable）时，Backspace 应用于文本编辑，不应触发删除节点/连线。
            const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
            const isEditable = tag === 'input' || tag === 'textarea' || tag === 'select' || (e.target && e.target.isContentEditable);
            if (isEditable) return;

            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (this.selectedConnection) {
                    this.deleteSelectedConnection();
                } else if (this.selectedNodeIds && this.selectedNodeIds.size > 0) {
                    this.deleteSelectedNodes();
                }
            }
        });
    }

    deleteSelectedNodes() {
        if (!this.selectedNodeIds || this.selectedNodeIds.size === 0) return;
        const ids = Array.from(this.selectedNodeIds);
        if (!confirm(`确认删除 ${ids.length} 个技能？`)) return;

        ids.forEach(id => {
            const idx = this.skills.findIndex(s => s.id === id);
            if (idx >= 0) this.skills.splice(idx, 1);
        });

        // Remove prerequisites pointing to deleted nodes
        this.skills.forEach(s => {
            if (Array.isArray(s.prerequisites)) {
                s.prerequisites = s.prerequisites.filter(p => !this.selectedNodeIds.has(p));
            }
        });

        this.clearSelection();
        this.renderNodes();
        this.renderSkillLibrary();
        this.loadProperties(null);
    }

    updateTransform() {
        this.elTransformLayer.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.zoom})`;
    }

    // --- Selection Helpers (Multi-select) ---
    clearSelection() {
        this.selectedNodeIds?.clear();
        this.primarySelectedNodeId = null;
        this.selectedNodeId = null;
    }

    setPrimarySelection(id, { keepOthers = false } = {}) {
        if (!id) return;
        if (!keepOthers) this.selectedNodeIds.clear();
        this.selectedNodeIds.add(id);
        this.primarySelectedNodeId = id;
        this.selectedNodeId = id;
    }

    toggleSelection(id) {
        if (!id) return;
        if (this.selectedNodeIds.has(id)) {
            this.selectedNodeIds.delete(id);
            if (this.primarySelectedNodeId === id) {
                const next = this.selectedNodeIds.values().next();
                const newPrimary = next && !next.done ? next.value : null;
                this.primarySelectedNodeId = newPrimary;
                this.selectedNodeId = newPrimary;
            }
        } else {
            this.selectedNodeIds.add(id);
            this.primarySelectedNodeId = id;
            this.selectedNodeId = id;
        }

        if (!this.primarySelectedNodeId) {
            this.selectedNodeId = null;
        }
    }

    onNodeMouseDown(e, skill) {
        e.stopPropagation(); // Stop panning
        // Select logic
        // Important: Ctrl+mousedown is also the start of drag. If we treat it as a toggle,
        // multi-selection will be destroyed when starting a group drag.
        // Rule:
        // - No Ctrl: single-select
        // - Ctrl + mousedown on unselected node: add to selection
        // - Ctrl + mousedown on selected node: keep selection, just set it as primary
        if (e.ctrlKey) {
            if (this.selectedNodeIds.has(skill.id)) {
                this.setPrimarySelection(skill.id, { keepOthers: true });
            } else {
                this.toggleSelection(skill.id);
            }
        } else {
            this.setPrimarySelection(skill.id);
        }
        this.selectedConnection = null; // Deselect connection

        // Properties panel: only editable on single selection
        if (this.primarySelectedNodeId && this.selectedNodeIds.size === 1) {
            this.loadProperties(skill);
        } else {
            this.loadProperties(null);
        }
        this.renderNodes(); // Update selection visual
        this.renderConnections(); // Update connection visual

        // Drag logic logic
        if (e.target.classList.contains('node-anchor')) {
            // Start connection dragging
            this.startConnectionDrag(skill.id, e);
        } else {
            // Start node Move
            // If dragging a node that is not selected, switch to single select first
            if (!this.selectedNodeIds.has(skill.id)) {
                this.setPrimarySelection(skill.id);
                this.renderNodes();
            }
            this.isDragging = true;
            this.draggedNodeId = skill.id;
            this.lastMousePos = { x: e.clientX, y: e.clientY };
        }
    }

    // --- Connection Interaction ---

    startConnectionDrag(nodeId, e) {
        this.isConnecting = true;
        this.connectionStartId = nodeId;
        
        // 创建临时虚线
        this.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        this.tempLine.setAttribute('stroke', '#ff9900');
        this.tempLine.setAttribute('stroke-width', '2');
        this.tempLine.setAttribute('stroke-dasharray', '5,5');
        this.tempLine.setAttribute('marker-end', 'url(#arrowhead)');
        
        // 计算起点（使用 Anchor 的中心，或者简化使用节点中心）
        // 这里简化为：从实际点击的位置开始
        const startPos = this.getLayerPos(e.clientX, e.clientY);
        this.tempLine.setAttribute('x1', startPos.x);
        this.tempLine.setAttribute('y1', startPos.y);
        this.tempLine.setAttribute('x2', startPos.x);
        this.tempLine.setAttribute('y2', startPos.y);

        if (this.elTempLineGroup) {
            this.elTempLineGroup.appendChild(this.tempLine);
        }
    }

    updateConnectionDrag(e) {
        if (!this.tempLine) return;
        const currPos = this.getLayerPos(e.clientX, e.clientY);
        this.tempLine.setAttribute('x2', currPos.x);
        this.tempLine.setAttribute('y2', currPos.y);
    }

    endConnectionDrag(e) {
        this.isConnecting = false;
        
        // 清除临时线
        if (this.tempLine) {
            this.tempLine.remove();
            this.tempLine = null;
        }

        // 检测由于鼠标释放而在下方的元素
        // 注意：由于 SVG 层遮挡，直接 e.target 可能是 SVG。
        // 我们利用 document.elementFromPoint 或检查 e.target 的父级
        let targetEl = e.target;
        
        // 向上查找 .skill-node
        while (targetEl && !targetEl.classList?.contains('skill-node') && targetEl !== document.body) {
            targetEl = targetEl.parentElement;
        }

        if (targetEl && targetEl.classList.contains('skill-node')) {
            const targetId = targetEl.dataset.id;
            
            // 验证合法性
            if (targetId && targetId !== this.connectionStartId) {
                this.createConnection(this.connectionStartId, targetId);
            }
        }
        
        this.connectionStartId = null;
    }

    createConnection(sourceId, targetId) {
        // 逻辑：Source 是 Target 的前置 (Source -> Target)
        // 数据模型中：target.prerequisites = [sourceId, ...]
        
        const targetSkill = this.getSkillById(targetId);
        if (!targetSkill) return;

        if (!Array.isArray(targetSkill.prerequisites)) targetSkill.prerequisites = [];

        // 检查重复
        if (targetSkill.prerequisites.includes(sourceId)) {
            console.log('连接已存在');
            return;
        }

        // 更新数据
        targetSkill.prerequisites.push(sourceId);
        console.log(`创建连接: ${sourceId} -> ${targetId}`);
        
        this.renderNodes();
    }

    // --- D. Properties Panel Logic ---

    loadProperties(skill) {
        // Multi-select or no selection: show summary and disable editing
        if (!skill) {
            const count = this.selectedNodeIds ? this.selectedNodeIds.size : 0;

            document.getElementById('btn-save').disabled = true;
            document.getElementById('btn-dup').disabled = count !== 1;
            document.getElementById('btn-del').disabled = count === 0;
            document.getElementById('btn-add-apply').disabled = true;
            document.getElementById('btn-add-applySelf').disabled = true;
            document.getElementById('btn-add-remove').disabled = true;
            const btnSaveEffects = document.getElementById('btn-save-effects');
            if (btnSaveEffects) btnSaveEffects.disabled = true;
            if (this.elBtnAddEffect) this.elBtnAddEffect.disabled = true;
            if (this.elBtnOpenEffectsJson) this.elBtnOpenEffectsJson.disabled = true;
            if (this.elBtnApplyEffectsJson) this.elBtnApplyEffectsJson.disabled = true;
            if (this.elBtnCloseEffectsJson) this.elBtnCloseEffectsJson.disabled = true;
            if (this.elBtnValidateEffects) this.elBtnValidateEffects.disabled = true;

            if (this.elPropId) this.elPropId.value = '';
            if (this.elPropName) this.elPropName.value = '';
            if (this.elPropCost) this.elPropCost.value = '';
            if (this.elPropSpeed) this.elPropSpeed.value = '';
            if (this.elPropDesc) this.elPropDesc.value = '';
            if (this.elPropEffects) this.elPropEffects.value = '';
            this.elPrereqText.textContent = '—';
            this.elMetaX.value = '';
            this.elMetaY.value = '';

            if (count > 1) {
                this.elValidateSummary.textContent = `Multi-select: ${count} nodes`;
                this.elSummaryText.textContent = '多选模式：属性面板只读。可拖拽成组移动，或按 Delete 批量删除。';
                this.elSummaryBadge.textContent = `${count}`;
            } else {
                this.elValidateSummary.textContent = 'No selection';
                this.elSummaryText.textContent = 'Select a node to edit...';
                this.elSummaryBadge.textContent = '—';
            }

            this.setError(this.elErrId, null);
            this.setError(this.elErrTarget, null);
            this.setError(this.elErrBuffs, null);
            this.setError(this.elErrEffects, null);
            if (this.elEffectsList) this.elEffectsList.innerHTML = '<span style="color:#888;">(no effects)</span>';
            return;
        }

        // Enable buttons
        document.getElementById('btn-save').disabled = false;
        document.getElementById('btn-del').disabled = false;
        document.getElementById('btn-dup').disabled = false;
        document.getElementById('btn-add-apply').disabled = false;
        document.getElementById('btn-add-applySelf').disabled = false;
        document.getElementById('btn-add-remove').disabled = false;
        const btnSaveEffects = document.getElementById('btn-save-effects');
        if (btnSaveEffects) btnSaveEffects.disabled = false;
        if (this.elBtnAddEffect) this.elBtnAddEffect.disabled = false;
        if (this.elBtnOpenEffectsJson) this.elBtnOpenEffectsJson.disabled = false;
        if (this.elBtnApplyEffectsJson) this.elBtnApplyEffectsJson.disabled = false;
        if (this.elBtnCloseEffectsJson) this.elBtnCloseEffectsJson.disabled = false;
        if (this.elBtnValidateEffects) this.elBtnValidateEffects.disabled = false;

        if (this.elPropId) this.elPropId.value = skill.id || '';
        if (this.elPropName) this.elPropName.value = skill.name || '';
        if (this.elPropRarity) this.elPropRarity.value = skill.rarity || 'Common';
        if (this.elPropCost) this.elPropCost.value = skill.cost ?? 0;
        if (this.elPropSpeed) this.elPropSpeed.value = skill.speed ?? 0;
        if (this.elPropTargetType) this.elPropTargetType.value = skill.targetType || 'SINGLE_PART';
        if (this.elPropRequiredPart) this.elPropRequiredPart.value = skill.requiredPart || '';
        if (this.elTargetPartsDropdown && typeof this.setTargetPartsSelection === 'function') {
            this.setTargetPartsSelection(Array.isArray(skill.targetParts) ? skill.targetParts : []);
        }
        if (this.elPropType) this.elPropType.value = skill.type || '';
        if (this.elPropValue) this.elPropValue.value = skill.value ?? '';
        if (this.elPropValueType) this.elPropValueType.value = skill.valueType || '';
        if (this.elPropDesc) this.elPropDesc.value = skill.description || '';
        if (this.elPropEffects) this.elPropEffects.value = JSON.stringify(skill.effects || [], null, 2);
        this.renderEffectsEditor(skill.effects || []);
        this.elPrereqText.textContent = (skill.prerequisites || []).join(', ') || '—';
        this.elMetaX.value = skill.editorMeta?.x ?? '';
        this.elMetaY.value = skill.editorMeta?.y ?? '';

        this.renderBuffRefTables();
        this.updateSummary();
    }

    saveEffectsJson() {
        // Backward-compatible entry: Save Effects button.
        this.saveEffectsFromForm();
    }

    ensureEffectDefaults(eff) {
        const out = (eff && typeof eff === 'object' && !Array.isArray(eff)) ? JSON.parse(JSON.stringify(eff)) : {};
        if (!out.effectType) out.effectType = (this.enums.effectTypes && this.enums.effectTypes[0]) || 'DMG_HP';
        if (!out.amountType) out.amountType = (this.enums.amountTypes && this.enums.amountTypes[0]) || 'ABS';

        if (out.amountType === 'SCALING') {
            if (!out.scaling) out.scaling = {};
            if (typeof out.scaling.stat !== 'string') out.scaling.stat = '';
            if (typeof out.scaling.multiplier !== 'number') out.scaling.multiplier = 1;
            delete out.amount;
        } else {
            if (typeof out.amount !== 'number') out.amount = 0;
            delete out.scaling;
        }

        if (out.subjectOverride === '') delete out.subjectOverride;
        if (out.note === '') delete out.note;
        return out;
    }

    getEffectsFromForm() {
        if (!this.elEffectsList) return [];
        const rows = Array.from(this.elEffectsList.querySelectorAll('.effect-row[data-effect-index]'));
        const effects = [];
        for (const row of rows) {
            const idx = Number(row.getAttribute('data-effect-index'));
            const q = (sel) => row.querySelector(sel);
            const effectType = q('select[data-field="effectType"]')?.value;
            const amountType = q('select[data-field="amountType"]')?.value || 'ABS';
            const subjectOverride = q('select[data-field="subjectOverride"]')?.value;
            const note = q('input[data-field="note"]')?.value;

            const eff = {};
            if (effectType) eff.effectType = effectType;
            eff.amountType = amountType;
            if (subjectOverride) eff.subjectOverride = subjectOverride;
            if (note) eff.note = note;

            if (amountType === 'SCALING') {
                const scalingStat = q('input[data-field="scaling.stat"]')?.value || '';
                const scalingMulStr = q('input[data-field="scaling.multiplier"]')?.value;
                eff.scaling = {
                    stat: scalingStat,
                    multiplier: scalingMulStr === '' || scalingMulStr == null ? NaN : Number(scalingMulStr)
                };
            } else {
                const amountStr = q('input[data-field="amount"]')?.value;
                eff.amount = amountStr === '' || amountStr == null ? NaN : Number(amountStr);
            }

            effects[idx] = eff;
        }
        return effects.filter(Boolean).map(e => this.ensureEffectDefaults(e));
    }

    validateEffects(effects) {
        const errs = [];
        if (!Array.isArray(effects)) return ['effects 必须是数组'];

        for (let i = 0; i < effects.length; i++) {
            const eff = effects[i];
            if (!eff || typeof eff !== 'object' || Array.isArray(eff)) {
                errs.push(`Effect #${i + 1}: 必须是对象`);
                continue;
            }

            if (!eff.effectType) errs.push(`Effect #${i + 1}: 缺少 effectType`);
            else if (Array.isArray(this.enums.effectTypes) && !this.enums.effectTypes.includes(eff.effectType)) {
                errs.push(`Effect #${i + 1}: effectType=${eff.effectType} 不在 meta.enums.effectTypes 中`);
            }

            if (eff.amountType && Array.isArray(this.enums.amountTypes) && !this.enums.amountTypes.includes(eff.amountType)) {
                errs.push(`Effect #${i + 1}: amountType=${eff.amountType} 不在 meta.enums.amountTypes 中`);
            }

            const at = eff.amountType || 'ABS';
            if (at === 'SCALING') {
                if (!eff.scaling || typeof eff.scaling !== 'object') errs.push(`Effect #${i + 1}: amountType=SCALING 需要 scaling 对象`);
                else {
                    if (!eff.scaling.stat || typeof eff.scaling.stat !== 'string') errs.push(`Effect #${i + 1}: scaling.stat 必填`);
                    if (typeof eff.scaling.multiplier !== 'number' || Number.isNaN(eff.scaling.multiplier)) errs.push(`Effect #${i + 1}: scaling.multiplier 必须是数字`);
                }
            } else {
                if (typeof eff.amount !== 'number' || Number.isNaN(eff.amount)) errs.push(`Effect #${i + 1}: amount 必须是数字`);
            }

            if (eff.subjectOverride) {
                if (Array.isArray(this.enums.targetSubjects) && !this.enums.targetSubjects.includes(eff.subjectOverride)) {
                    errs.push(`Effect #${i + 1}: subjectOverride=${eff.subjectOverride} 不在 meta.enums.targetSubjects 中`);
                }
            }
        }

        return errs;
    }

    renderEffectsEditor(effects) {
        if (!this.elEffectsList) return;
        const list = Array.isArray(effects) ? effects : [];
        if (list.length === 0) {
            this.elEffectsList.innerHTML = '<span style="color:#888;">(no effects)</span>';
            return;
        }

        this.elEffectsList.innerHTML = '';
        list.forEach((rawEff, index) => {
            const eff = this.ensureEffectDefaults(rawEff);
            const row = document.createElement('div');
            row.className = 'effect-row';
            row.setAttribute('data-effect-index', String(index));

            const head = document.createElement('div');
            head.className = 'effect-row-head';
            head.innerHTML = `<div style="font-weight:800;">Effect #${index + 1}</div>`;
            const actions = document.createElement('div');
            actions.className = 'row-actions';
            actions.innerHTML = `
                <button class="btn btn-sm btn-dark" type="button" data-action="up">↑</button>
                <button class="btn btn-sm btn-dark" type="button" data-action="down">↓</button>
                <button class="btn btn-sm btn-dark" type="button" data-action="dup">Dup</button>
                <button class="btn btn-sm btn-danger" type="button" data-action="del">Del</button>
            `;
            head.appendChild(actions);

            const grid = document.createElement('div');
            grid.className = 'effect-grid';

            const mkSelect = (field, options, value, allowEmpty = false, emptyLabel = '(inherit)') => {
                const sel = document.createElement('select');
                sel.className = 'select';
                sel.setAttribute('data-field', field);
                const opts = [];
                if (allowEmpty) opts.push(`<option value="">${emptyLabel}</option>`);
                (options || []).forEach(o => opts.push(`<option value="${o}">${o}</option>`));
                sel.innerHTML = opts.join('');
                if (value != null) sel.value = value;
                return sel;
            };
            const mkInput = (field, type, value, placeholder = '') => {
                const input = document.createElement('input');
                input.className = 'input';
                input.type = type;
                input.setAttribute('data-field', field);
                input.placeholder = placeholder;
                input.value = value == null ? '' : String(value);
                return input;
            };
            const addRow = (label, el) => {
                const l = document.createElement('div');
                l.className = 'small';
                l.textContent = label;
                grid.appendChild(l);
                grid.appendChild(el);
            };

            addRow('effectType', mkSelect('effectType', this.enums.effectTypes, eff.effectType));
            addRow('amountType', mkSelect('amountType', this.enums.amountTypes, eff.amountType));

            if (eff.amountType === 'SCALING') {
                addRow('scaling.stat', mkInput('scaling.stat', 'text', eff.scaling?.stat || '', 'e.g. atk'));
                addRow('scaling.multiplier', mkInput('scaling.multiplier', 'number', eff.scaling?.multiplier ?? 1, 'e.g. 1.2'));
            } else {
                addRow('amount', mkInput('amount', 'number', eff.amount ?? 0));
                addRow('', document.createElement('div'));
            }

            addRow('subjectOverride', mkSelect('subjectOverride', this.enums.targetSubjects, eff.subjectOverride || '', true));
            addRow('note', mkInput('note', 'text', eff.note || '', 'optional'));

            row.appendChild(head);
            row.appendChild(grid);
            this.elEffectsList.appendChild(row);

            actions.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-action]');
                if (!btn) return;
                const action = btn.getAttribute('data-action');
                if (action === 'up') this.moveEffectRow(index, -1);
                if (action === 'down') this.moveEffectRow(index, +1);
                if (action === 'dup') this.duplicateEffectRow(index);
                if (action === 'del') this.deleteEffectRow(index);
            });

            grid.addEventListener('change', (e) => {
                const field = e.target?.getAttribute?.('data-field');
                if (field === 'amountType') {
                    const current = this.getEffectsFromForm();
                    this.renderEffectsEditor(current);
                    this.syncEffectsJsonFromForm();
                } else {
                    this.syncEffectsJsonFromForm();
                }
            });
            grid.addEventListener('input', () => this.syncEffectsJsonFromForm());
        });
    }

    syncEffectsJsonFromForm() {
        if (!this.elPropEffects) return;
        const effects = this.getEffectsFromForm();
        this.elPropEffects.value = JSON.stringify(effects, null, 2);
    }

    addEffectRow() {
        if (!this.selectedNodeId) return;
        const skill = this.getSkillById(this.selectedNodeId);
        if (!skill) return;
        if (!Array.isArray(skill.effects)) skill.effects = [];

        const eff = this.ensureEffectDefaults({
            effectType: (this.enums.effectTypes && this.enums.effectTypes[0]) || 'DMG_HP',
            amountType: (this.enums.amountTypes && this.enums.amountTypes[0]) || 'ABS',
            amount: 0
        });
        skill.effects.push(eff);
        this.renderEffectsEditor(skill.effects);
        this.syncEffectsJsonFromForm();
    }

    moveEffectRow(index, delta) {
        if (!this.selectedNodeId) return;
        const skill = this.getSkillById(this.selectedNodeId);
        if (!skill || !Array.isArray(skill.effects)) return;
        const to = index + delta;
        if (to < 0 || to >= skill.effects.length) return;
        const tmp = skill.effects[index];
        skill.effects[index] = skill.effects[to];
        skill.effects[to] = tmp;
        this.renderEffectsEditor(skill.effects);
        this.syncEffectsJsonFromForm();
    }

    duplicateEffectRow(index) {
        if (!this.selectedNodeId) return;
        const skill = this.getSkillById(this.selectedNodeId);
        if (!skill || !Array.isArray(skill.effects)) return;
        const src = skill.effects[index];
        if (!src) return;
        skill.effects.splice(index + 1, 0, JSON.parse(JSON.stringify(src)));
        this.renderEffectsEditor(skill.effects);
        this.syncEffectsJsonFromForm();
    }

    deleteEffectRow(index) {
        if (!this.selectedNodeId) return;
        const skill = this.getSkillById(this.selectedNodeId);
        if (!skill || !Array.isArray(skill.effects)) return;
        skill.effects.splice(index, 1);
        this.renderEffectsEditor(skill.effects);
        this.syncEffectsJsonFromForm();
    }

    openEffectsJsonSync() {
        if (this.elEffectsJsonWrap) this.elEffectsJsonWrap.style.display = 'block';
        this.syncEffectsJsonFromForm();
    }

    closeEffectsJsonSync() {
        if (this.elEffectsJsonWrap) this.elEffectsJsonWrap.style.display = 'none';
    }

    applyEffectsJsonToForm() {
        this.setError(this.elErrEffects, null);
        let parsed;
        try {
            parsed = JSON.parse(this.elPropEffects?.value || '[]');
            if (!Array.isArray(parsed)) throw new Error('effects 必须是数组');
        } catch (e) {
            this.setError(this.elErrEffects, e.message || String(e));
            return;
        }
        if (!this.selectedNodeId) return;
        const skill = this.getSkillById(this.selectedNodeId);
        if (!skill) return;
        skill.effects = parsed.map(e => this.ensureEffectDefaults(e));
        this.renderEffectsEditor(skill.effects);
        this.syncEffectsJsonFromForm();
    }

    validateEffectsFromForm() {
        this.setError(this.elErrEffects, null);
        const effects = this.getEffectsFromForm();
        const errs = this.validateEffects(effects);
        if (errs.length) {
            this.setError(this.elErrEffects, errs.join('\n'));
            return false;
        }
        return true;
    }

    saveEffectsFromForm() {
        if (!this.selectedNodeId) return;
        const skill = this.getSkillById(this.selectedNodeId);
        if (!skill) return;
        if (!this.validateEffectsFromForm()) {
            this.updateSummary();
            return;
        }
        const effects = this.getEffectsFromForm();
        skill.effects = effects;
        if (this.elPropEffects) this.elPropEffects.value = JSON.stringify(effects, null, 2);
        this.closeEffectsJsonSync();
        this.updateSummary();
    }

    saveCurrentNode() {
        if (!this.selectedNodeId) return;
        const skill = this.getSkillById(this.selectedNodeId);
        if (!skill) return;

        // Clear errors
        this.setError(this.elErrId, null);
        this.setError(this.elErrTarget, null);
        this.setError(this.elErrBuffs, null);
        this.setError(this.elErrEffects, null);

        // id is read-only (do not allow editing)
        const newId = skill.id;

        // Target validation
        const targetType = this.elPropTargetType.value;
        const requiredPart = this.elPropRequiredPart.value || undefined;
        const targetParts = this.getSelectedTargetParts();
        if (targetType === 'SELF_PARTS' && targetParts.length === 0) {
            this.setError(this.elErrTarget, 'targetType=SELF_PARTS 时必须填写 targetParts');
            this.updateSummary();
            return;
        }

        // NOTE: effects uses dedicated Validate/Save button; do not parse/write here.

        // Apply changes
        skill.id = newId;
        skill.name = (this.elPropName.value || '').trim();
        skill.rarity = this.elPropRarity.value;
        skill.cost = Number(this.elPropCost.value || 0);
        skill.speed = Number(this.elPropSpeed.value || 0);
        skill.targetType = targetType;

        if (requiredPart) skill.requiredPart = requiredPart; else delete skill.requiredPart;
        if (targetParts.length > 0) skill.targetParts = targetParts; else delete skill.targetParts;

        const type = (this.elPropType.value || '').trim();
        if (type) skill.type = type; else delete skill.type;

        const valueRaw = (this.elPropValue.value || '').trim();
        if (valueRaw === '') {
            delete skill.value;
        } else {
            const maybeNumber = Number(valueRaw);
            skill.value = Number.isNaN(maybeNumber) ? valueRaw : maybeNumber;
        }

        const valueType = (this.elPropValueType.value || '').trim();
        if (valueType) skill.valueType = valueType; else delete skill.valueType;

        skill.description = this.elPropDesc.value || '';

        // Keep editorMeta in sync on UI
        this.elMetaX.value = skill.editorMeta?.x ?? '';
        this.elMetaY.value = skill.editorMeta?.y ?? '';

        // id is read-only; no rename flow.

        this.renderNodes();
        this.renderSkillLibrary();
        this.updateSummary();
    }

    deleteCurrentNode() {
        if (!this.selectedNodeId) return;
        if (confirm('确认删除技能 ' + this.selectedNodeId + '?')) {
            this.skills = this.skills.filter(s => s.id !== this.selectedNodeId);
            // Also remove connections
            this.skills.forEach(s => {
                if (s.prerequisites) {
                    s.prerequisites = s.prerequisites.filter(pid => pid !== this.selectedNodeId);
                }
            });
            this.selectedNodeId = null;
            this.renderNodes();
        }
    }

    deleteSelectedConnection() {
        if (!this.selectedConnection) return;
        
        const { source, target } = this.selectedConnection;
        const targetSkill = this.getSkillById(target);
        
        if (targetSkill) {
            if (Array.isArray(targetSkill.prerequisites)) {
                targetSkill.prerequisites = targetSkill.prerequisites.filter(pid => pid !== source);
            }
            console.log(`已删除连接: ${source} -> ${target}`);
        }
        
        this.selectedConnection = null;
        this.renderConnections();
    }

    // --- Buttons ---

    createNewSkill() {
        const newId = 'skill_' + Date.now();
        // Place in center of view (approx)
        const vX = (-this.pan.x + 200) / this.zoom;
        const vY = (-this.pan.y + 200) / this.zoom;
        
        this.addSkillNode({
            id: newId,
            name: '新技能',
            rarity: 'Common',
            cost: 1,
            speed: 0,
            targetType: 'SINGLE_PART',
            prerequisites: [],
            buffRefs: { apply: [], applySelf: [], remove: [] },
            effects: [],
            editorMeta: { x: vX, y: vY }
        });
    }

    clearCanvas() {
        if(confirm('确认清空所有内容？')) {
            this.skills = [];
            this.renderNodes();
        }
    }
    
    async loadProjectData() {
        try {
            const [skillsResp, buffsResp] = await Promise.all([
                fetch('../assets/data/skills_melee_v3.json'),
                fetch('../assets/data/buffs.json')
            ]);
            const skillsData = await skillsResp.json();
            const buffsData = await buffsResp.json();

            this.buffDict = buffsData || {};

            // skills_melee_v3.json format: { meta, skills: [] }
            const newSkills = [];
            if (skillsData && typeof skillsData === 'object' && Array.isArray(skillsData.skills)) {
                this.setSkillPackMeta(skillsData.meta || null, skillsData.$schemaVersion || null);
                skillsData.skills.forEach((sk) => {
                    if (!sk || typeof sk !== 'object') return;
                    if (!sk.id) return;
                    newSkills.push(this.fromV3Skill(sk));
                });
            } else {
                // legacy object map fallback
                Object.keys(skillsData || {}).forEach((key) => {
                    const sk = skillsData[key];
                    if (!sk.id) sk.id = key;
                    newSkills.push(sk);
                });
            }
            this.normalizeImportedSkills(newSkills);
            this.skills = newSkills;
            this.selectedNodeId = null;
            this.renderNodes();
            this.pan = { x: 0, y: 0 };
            this.zoom = 1;
            this.updateTransform();
            alert(`Loaded skills: ${this.skills.length}, buffs: ${Object.keys(this.buffDict).length}`);
        } catch (e) {
            console.error(e);
            alert('Load Project Data failed: ' + e.message);
        }
    }

    importJsonFile(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                const newSkills = [];
                if (Array.isArray(data)) {
                    // legacy array format
                    data.forEach(s => newSkills.push(s));
                } else if (data && typeof data === 'object' && Array.isArray(data.skills)) {
                    // v3 format: { $schemaVersion, meta, skills: [] }
                    this.setSkillPackMeta(data.meta || null, data.$schemaVersion || null);
                    data.skills.forEach((sk) => {
                        if (!sk || typeof sk !== 'object') return;
                        if (!sk.id) return;
                        newSkills.push(this.fromV3Skill(sk));
                    });
                } else if (typeof data === 'object' && data !== null) {
                    // legacy object map
                    Object.keys(data).forEach(k => {
                        const s = data[k];
                        if (!s.id) s.id = k;
                        newSkills.push(s);
                    });
                } else {
                    throw new Error('未知 JSON 格式');
                }

                this.normalizeImportedSkills(newSkills);
                if (confirm(`解析成功：${newSkills.length} skills。覆盖当前画布？`)) {
                    this.skills = newSkills;
                    this.selectedNodeId = null;
                    this.renderNodes();
                    this.renderSkillLibrary();
                }
            } catch (err) {
                console.error(err);
                alert('导入失败: ' + err.message);
            }
            input.value = '';
        };
        reader.readAsText(file);
    }

    normalizeImportedSkills(newSkills) {
        newSkills.forEach((skill, index) => {
            // Migrate legacy preRequisite/preRequisites -> prerequisites
            if (skill.preRequisite && !skill.prerequisites) {
                skill.prerequisites = [skill.preRequisite];
                delete skill.preRequisite;
            }
            if (skill.preRequisites && !skill.prerequisites) {
                skill.prerequisites = skill.preRequisites;
                delete skill.preRequisites;
            }
            if (!Array.isArray(skill.prerequisites)) skill.prerequisites = [];

            if (!skill.buffRefs) skill.buffRefs = { apply: [], applySelf: [], remove: [] };
            if (!skill.buffRefs.apply) skill.buffRefs.apply = [];
            if (!skill.buffRefs.applySelf) skill.buffRefs.applySelf = [];
            if (!skill.buffRefs.remove) skill.buffRefs.remove = [];

            if (!Array.isArray(skill.effects)) skill.effects = [];

            // v3 -> legacy mirror: costs.ap -> cost
            if (skill.costs && typeof skill.costs.ap === 'number') {
                skill.cost = skill.costs.ap;
            }

            if (!skill.editorMeta) {
                const col = index % 10;
                const row = Math.floor(index / 10);
                skill.editorMeta = { x: col * this.GRID_SIZE + 14, y: row * this.GRID_SIZE + 14 };
            } else {
                this.snapToGrid(skill.editorMeta);
            }
        });
    }

    exportJson(includeEditorMeta = true) {
        // Export v3 by default (preserve meta + array format), but keep a legacy option via includeEditorMeta flag
        const skillsV3 = this.skills.map(s => {
            const clone = JSON.parse(JSON.stringify(s));
            if (!includeEditorMeta) delete clone.editorMeta;
            return this.toV3Skill(clone);
        });

        const pack = {
            $schemaVersion: this.skillPackSchemaVersion || 'skills_melee_v3',
            meta: this.skillPackMeta || {
                title: 'Skills Export',
                source: 'skill_editor_test_v2',
                notes: ['exported by skill_editor_test_v2.html'],
                defaultParts: (this.defaultParts || []).slice(),
                enums: this.enums
            },
            skills: skillsV3
        };

        const jsonStr = JSON.stringify(pack, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = includeEditorMeta ? 'skills_melee_v3_export.dev.json' : 'skills_melee_v3_export.runtime.json';
        document.body.appendChild(a);
        a.click();
        
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    duplicateCurrentNode() {
        if (!this.selectedNodeId) return;
        const src = this.getSkillById(this.selectedNodeId);
        if (!src) return;
        const copy = JSON.parse(JSON.stringify(src));
        copy.id = `${src.id}_copy_${Date.now()}`;
        copy.name = `${src.name || 'Skill'} (Copy)`;
        copy.prerequisites = Array.isArray(src.prerequisites) ? [...src.prerequisites] : [];
        copy.editorMeta = { x: (src.editorMeta?.x ?? 14) + 100, y: (src.editorMeta?.y ?? 14) + 0 };
        this.addSkillNode(copy);
    }

    setError(el, msg) {
        if (!el) return;
        if (!msg) {
            el.style.display = 'none';
            el.textContent = '';
        } else {
            el.style.display = 'block';
            el.textContent = msg;
        }
    }

    updateSummary() {
        const skill = this.selectedNodeId ? this.getSkillById(this.selectedNodeId) : null;
        if (!skill) {
            this.elValidateSummary.textContent = 'No selection';
            this.elSummaryText.textContent = 'Select a node to edit...';
            this.elSummaryBadge.textContent = '—';
            return;
        }
        const issues = [];
        if (!skill.id) issues.push('missing id');
        if (skill.buffRefs) {
            const all = [];
            ['apply','applySelf','remove'].forEach(k => {
                (skill.buffRefs[k] || []).forEach(r => all.push(r));
            });
            all.forEach(r => {
                if (r?.buffId && this.buffDict && Object.keys(this.buffDict).length > 0) {
                    if (!this.buffDict[r.buffId]) issues.push(`unknown buffId: ${r.buffId}`);
                }
                if (typeof r?.chance === 'number' && (r.chance < 0 || r.chance > 1)) issues.push('chance out of range');
            });
        }
        this.elValidateSummary.textContent = issues.length === 0 ? 'OK' : `${issues.length} issue(s)`;
        this.elSummaryBadge.textContent = issues.length === 0 ? '✅ OK' : '⚠️';
        this.elSummaryText.textContent = `${skill.id} / ${skill.name || ''}`;
    }

    renderBuffRefTables() {
        const skill = this.selectedNodeId ? this.getSkillById(this.selectedNodeId) : null;
        const tables = {
            apply: document.querySelector('#table-apply tbody'),
            applySelf: document.querySelector('#table-applySelf tbody'),
            remove: document.querySelector('#table-remove tbody'),
        };
        Object.values(tables).forEach(t => { if (t) t.innerHTML = ''; });
        if (!skill) return;

        const renderBuffIdSelect = (value) => {
            const buffIds = Object.keys(this.buffDict || {});
            if (buffIds.length === 0) {
                return `<input class="input" data-field="buffId" value="${value || ''}" placeholder="buffId"/>`;
            }
            const options = ['<option value="">(select)</option>']
                .concat(buffIds.map(id => `<option value="${id}" ${id===value?'selected':''}>${id}</option>`));
            return `<select class="select" data-field="buffId">${options.join('')}</select>`;
        };

        const renderRow = (kind, row, index) => {
            if (kind === 'remove') {
                return `
                    <tr data-kind="${kind}" data-index="${index}">
                        <td>${renderBuffIdSelect(row.buffId)}</td>
                        <td>
                            <select class="select" data-field="target">
                                <option value="self" ${(row.target||'self')==='self'?'selected':''}>self</option>
                                <option value="enemy" ${(row.target||'self')==='enemy'?'selected':''}>enemy</option>
                            </select>
                        </td>
                        <td><button class="btn btn-sm btn-danger" data-action="del">Del</button></td>
                    </tr>
                `;
            }
            return `
                <tr data-kind="${kind}" data-index="${index}">
                    <td>${renderBuffIdSelect(row.buffId)}</td>
                    <td>
                        <select class="select" data-field="target">
                            <option value="enemy" ${(row.target||'enemy')==='enemy'?'selected':''}>enemy</option>
                            <option value="self" ${(row.target||'enemy')==='self'?'selected':''}>self</option>
                        </select>
                    </td>
                    <td><input class="input" data-field="chance" type="number" step="0.01" value="${row.chance ?? 1}"/></td>
                    <td><input class="input" data-field="duration" type="number" value="${row.duration ?? ''}"/></td>
                    <td><input class="input" data-field="stacks" type="number" value="${row.stacks ?? ''}"/></td>
                    <td><button class="btn btn-sm btn-danger" data-action="del">Del</button></td>
                </tr>
            `;
        };

        ['apply','applySelf','remove'].forEach(kind => {
            const arr = skill.buffRefs?.[kind] || [];
            arr.forEach((row, idx) => {
                tables[kind].insertAdjacentHTML('beforeend', renderRow(kind, row, idx));
            });
        });

        // Wire events once via event delegation
        const container = document.getElementById('properties-panel');
        if (!this._buffRefDelegated) {
            this._buffRefDelegated = true;
            container.addEventListener('change', (e) => {
                const tr = e.target.closest('tr[data-kind]');
                if (!tr) return;
                const kind = tr.dataset.kind;
                const index = Number(tr.dataset.index);
                const field = e.target.dataset.field;
                if (!field) return;
                const sk = this.getSkillById(this.selectedNodeId);
                if (!sk) return;
                const row = sk.buffRefs[kind][index];
                let v = e.target.value;
                if (field === 'chance' || field === 'duration' || field === 'stacks') {
                    v = v === '' ? undefined : Number(v);
                }
                row[field] = v;
                this.updateSummary();
            });
            container.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-action="del"]');
                if (!btn) return;
                const tr = e.target.closest('tr[data-kind]');
                if (!tr) return;
                const kind = tr.dataset.kind;
                const index = Number(tr.dataset.index);
                const sk = this.getSkillById(this.selectedNodeId);
                if (!sk) return;
                sk.buffRefs[kind].splice(index, 1);
                this.renderBuffRefTables();
                this.updateSummary();
            });
        }
    }

    addBuffRefRow(kind) {
        if (!this.selectedNodeId) return;
        const sk = this.getSkillById(this.selectedNodeId);
        if (!sk) return;
        if (!sk.buffRefs) sk.buffRefs = { apply: [], applySelf: [], remove: [] };
        if (!Array.isArray(sk.buffRefs[kind])) sk.buffRefs[kind] = [];
        if (kind === 'remove') {
            sk.buffRefs[kind].push({ buffId: '', target: 'self' });
        } else {
            sk.buffRefs[kind].push({ buffId: '', target: kind === 'applySelf' ? 'self' : 'enemy', chance: 1.0 });
        }
        this.renderBuffRefTables();
        this.updateSummary();
    }

    autoLayout() {
        alert('自动布局功能尚未实现。');
    }
}

// Start App
const editor = new SkillEditor();

</script>
</body>
</html>
