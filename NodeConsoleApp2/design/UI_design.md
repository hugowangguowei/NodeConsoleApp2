# UI 设计文档 (UI_design.md)

本文档基于 `mock_ui_v5.html` 及 `mock_ui_v5.css` 编写，详细描述了网页回合制战斗系统的界面设计、视觉风格、交互逻辑及与游戏引擎的接口定义。

## 1. 界面布局设计

界面采用 **1920x1080** 分辨率的固定布局（`.app-shell`），整体采用 Grid 和 Flexbox 混合布局。

### 1.1 整体结构
主界面 (`main`) 位于屏幕中央，分为上下三个主要区域（Grid 布局）：

#### 1.1.1 上部：战斗场景与状态区 (Scene Wrapper)
*   **高度**: 546px
*   **容器样式**: 深蓝背景 (`#252b45`)，圆角边框，带阴影。
*   **布局**: 包含顶部的时间轴和下方的战斗主体行。

**(1) 时间轴 (.timeline)**
*   **位置**: 顶部区域。
*   **功能**: 横向排列显示当前回合的行动顺序。
*   **组件细节**:
    *   **Timeline Item**: 每个单位的行动卡片，包含单位名称、行动类型及速度值。
    *   **连接线**: 贯穿所有 Item 的水平线条，指示时间流向。

**(2) 战斗主体行 (.battle-row)**
*   **布局**: Grid 布局，分为三列：左侧玩家状态、中间战斗场景、右侧敌人状态。

*   **左侧：玩家状态面板 (.player-hud)**
    *   **宽度**: 420px。
    *   **基础属性**: 包含 HP 条（红渐变）、AP 条（青渐变），显示当前值/最大值。
    *   **状态栏 (.status-row)**: 分为 BUFF 和 DEBUFF 两行，显示状态图标 (`.status-icon`)，悬停显示详情。
    *   **护甲列表 (.armor-list-wrapper)**: 垂直列表，显示各部位（头、胸、腹、四肢）的护甲值及损耗进度条。

*   **中间：战斗场景可视区 (.battle-scene)**
    *   **宽度**: 自适应 (1fr)。
    *   **层级结构**:
        *   **背景层 (.stage-background)**: 显示场景图片（如森林）。
        *   **角色层 (.fighters-layer)**: 包含玩家和敌人的立绘容器 (`.fighter`)。
            *   **立绘容器**: 支持多层叠加（素体、装备、武器）。
            *   **阴影**: 角色脚底的圆形阴影。
            *   **特效挂载点 (.effect-anchor)**: 用于播放受击、施法特效。
        *   **特效层 (.fx-layer)**: 最上层，用于显示全屏特效或伤害数字。

*   **右侧：敌人状态面板 (.enemy-hud)**
    *   **宽度**: 420px。
    *   **布局**: 与玩家面板对称（右对齐），内容结构一致。

#### 1.1.2 中部：操作与信息区 (Action Panel)
*   **高度**: 286px
*   **容器样式**: 深色背景 (`#2c3350`)，带青色边框 (`#7cf5d9`)。
*   **布局**: Flex 布局，分为左右两部分。

**(1) 技能面板 (.skill-panel)**
*   **占比**: Flex 9。
*   **布局**: 包含左侧的选择区和右侧的详情区。

*   **技能选择区 (.skill-selection-wrapper)**
    *   **技能网格 (.skill-grid-view)**: 自动填充的 Grid 布局，显示技能图标按钮 (`.skill-icon-button`)。
    *   **排序栏 (.skill-sort-bar)**: 底部工具栏，包含“默认”、“AP消耗”、“目标类型”等排序按钮。

*   **技能详情区 (.skill-detail)**
    *   **内容**: 显示当前选中技能的完整信息。
    *   **组件**: 技能名称标题、元数据（类型/消耗/速度）、效果描述文本、战术提示、标签组（如“单体”、“物理”）。

**(2) 回合控制面板 (.turn-panel)**
*   **占比**: Flex 1。
*   **功能**: 包含回合流程控制按钮。
*   **组件**: 垂直排列的按钮组 (`.turn-buttons`)，包括“上一回合”、“暂停”（警告色）、“开始”（主色调）。

#### 1.1.3 下部区域
(预留区域，当前版本 CSS 定义了第三行 186px，但 HTML 中暂未填充内容，Footer 位于 Main 之外)。

### 1.2 模态窗口 (System Modal)
*   **定位**: 绝对定位覆盖全屏，居中显示。
*   **尺寸**: 宽度 600px，最大高度 85vh。
*   **用途**: 用于系统菜单、关卡选择、存档/读档等非战斗操作。
*   **组件结构**:
    *   **标题栏 (.modal-header)**: 显示模态框标题，包含关闭按钮。
    *   **内容区 (.modal-content)**: 根据不同视图渲染不同内容。
    *   **底部操作区 (.modal-footer)**: 显示确认/取消按钮。

## 2. 颜色与字体设计

界面风格偏向 **深色科幻/魔幻风格**，使用冷色调为主，高亮色为辅。

### 2.1 颜色板
*   **背景色**:
    *   全局背景: 深蓝渐变 (`#1f2440` 到 `#151a2b`)。
    *   容器背景: 半透明深蓝 (`rgba(32,38,63,0.94)`), 面板背景 (`#252b45`, `#2f3551`, `#2c3350`)。
*   **文字颜色**:
    *   主要文字: 亮白/淡蓝 (`#f4f6ff`, `#e5eaff`)。
    *   次要文字: 灰蓝 (`#cbd6ff`, `#8fa3bf`)。
    *   标签文字: 强调色 (`#81a5ff`, `#7cf5d9`, `#c08bff`)。
*   **功能色**:
    *   **玩家/友方**: 亮蓝/青色 (`#57c2ff`, `#7cf5d9`)。
    *   **敌人/敌对**: 红色/粉红 (`#ff5f5f`, `#ff9dbb`)。
    *   **中立/系统**: 紫色 (`#c08bff`), 金色 (`#ffd266`).
    *   **HP 条**: 红渐变 (`#ff8e8e` -> `#ff5f5f`)。
    *   **AP 条**: 青渐变 (`#7bffcf` -> `#4ff3a0`)。

### 2.2 字体与排版
*   **字体**: 默认系统无衬线字体，强调数字和标题的清晰度。
*   **字号**:
    *   标题: 1.1rem - 1.2rem。
    *   正文: 0.8rem - 0.9rem。
    *   标签/小字: 0.6rem - 0.75rem。
*   **装饰**: 大量使用边框 (`border`), 阴影 (`box-shadow`), 圆角 (`border-radius`) 和 渐变 (`linear-gradient`) 来营造质感。

## 3. 交互设计

### 3.1 技能选择
*   **操作**: 点击 `.skill-icon-button`。
*   **反馈**:
    *   **Hover**: 边框变金 (`#ffd700`)，图标放大，层级提升。
    *   **Active (选中)**: 边框变青 (`#7cf5d9`)，添加发光阴影。
    *   **联动**: 点击技能后，右侧 `.skill-detail` 面板会实时更新显示该技能的名称、消耗、效果、目标等信息。

### 3.2 技能排序
*   **操作**: 点击 `.skill-sort-bar` 中的排序按钮（默认、AP消耗、目标类型）。
*   **反馈**: 按钮高亮，下方的技能列表根据对应规则重新排列。

### 3.3 回合控制
*   **操作**: 点击 `.turn-button` (上一回合、暂停、开始)。
*   **反馈**: 按钮有按压效果 (`transform: translateY`) 和 阴影变化。

### 3.4 系统菜单
*   **入口**: 点击右上角悬浮按钮 (`.system-menu-btn`)。
*   **交互**: 弹出模态窗口，背景模糊。点击菜单项可跳转不同子视图（关卡选择、存档列表）。
*   **关闭**: 点击关闭按钮 (`×`) 或遮罩层（如果实现）关闭窗口。

### 3.5 状态提示 (Tooltip)
*   **操作**: 鼠标悬停在状态图标 (`.status-icon`) 上。
*   **反馈**: 显示 CSS 实现的 Tooltip，展示 Buff/Debuff 名称及描述。

## 4. 接口设计 (UI <-> Engine)

为了实现 UI 与游戏引程的解耦，建议采用 **数据驱动** 的方式。UI 模块不直接持有游戏逻辑，而是通过监听事件或绑定数据对象来更新视图。

### 4.1 接收数据 (Engine -> UI)

UI 需要监听以下数据变化或事件来更新显示：

| UI 模块 | 数据源 / 事件 | 数据结构示例 | 更新内容 |
| :--- | :--- | :--- | :--- |
| **Timeline** | `TurnOrderUpdated` | `[{ name: "玩家", action: "重斩", speed: 14, isPlayer: true }, ...]` | 更新顶部行动顺序条的图标和文字。 |
| **Player HUD** | `PlayerStatsUpdated` | `{ hp: 120, maxHp: 150, ap: 4, maxAp: 6, armor: { head: 30, ... }, buffs: [...] }` | 更新 HP/AP 进度条、数值、护甲条、状态图标。 |
| **Enemy HUD** | `EnemyStatsUpdated` | `{ name: "暗影刺客", hp: 80, maxHp: 120, ap: 3, ... }` | 更新敌人名称、HP/AP、护甲、状态图标。 |
| **Skill List** | `PlayerSkillsUpdated` | `[{ id: "s1", name: "重斩", cost: 2, type: "physical", ... }]` | 重新渲染技能网格列表。 |
| **Battle Scene** | `SceneStateUpdated` | `{ playerSprite: "url...", enemySprite: "url...", background: "url..." }` | 更新角色立绘、背景图片。 |
| **Battle Log** | `CombatLogEmitted` | `{ source: "玩家", target: "敌人", action: "攻击", value: 50 }` | (如有日志面板) 显示战斗文本。 |

### 4.2 发送指令 (UI -> Engine)

UI 通过调用引擎提供的 API 或发送事件来传达用户操作：

| 交互操作 | 触发事件 / 调用方法 | 参数示例 | 说明 |
| :--- | :--- | :--- | :--- |
| **选择技能** | `UI_SelectSkill` | `{ skillId: "skill_01" }` | 玩家点击了某个技能，引擎需记录待释放技能。 |
| **取消技能** | `UI_DeselectSkill` | `{ skillId: "skill_01" }` | (如果支持多选) 玩家取消了已选技能。 |
| **开始回合** | `UI_StartTurn` | `null` | 玩家点击“开始”按钮，引擎开始结算回合。 |
| **暂停/继续** | `UI_TogglePause` | `null` | 玩家点击暂停/继续按钮。 |
| **加载关卡** | `UI_LoadLevel` | `{ levelId: "1-1" }` | 在系统菜单中选择了关卡。 |
| **保存游戏** | `UI_SaveGame` | `{ slotId: 1 }` | 在存档菜单中点击保存。 |
| **读取游戏** | `UI_LoadGame` | `{ slotId: 1 }` | 在读档菜单中点击读取。 |

### 4.3 视图状态管理
*   **Skill Detail**: 纯前端逻辑。点击技能图标时，UI 层直接根据 DOM 数据 (`data-*` 属性) 或缓存的技能数据更新详情面板，无需请求引擎（除非数据是动态变化的）。
*   **Sorting**: 纯前端逻辑。UI 层根据当前的技能列表 DOM 元素进行排序，不影响引擎内部数据。

### 4.4 模态窗口接口详解 (System Modal Interface)

模态框作为游戏中的“元操作”界面（登录、菜单、存档、选关），是游戏非战斗状态下的主要交互载体。

#### 4.4.1 监听事件 (Engine -> Modal)

模态框主要监听以下事件来决定显示内容或更新列表：

| 事件名称 | 触发时机 | 数据结构示例 | 模态框处置逻辑 |
| :--- | :--- | :--- | :--- |
| `STATE_CHANGED` | 引擎状态机发生流转时 | `{ from: "INIT", to: "LOGIN" }` | 根据 `to` 的状态值切换模态框的根视图（如登录页、主菜单）。 |
| `DATA_UPDATE` | 存档数据或全局配置更新时 | `{ type: "SAVE_LIST", data: [...] }` | 若当前处于“存档/读档”视图，根据 `data` 刷新存档槽位列表。 |
| `UI:OPEN_MODAL` | UI 逻辑请求打开模态框（如点击设置按钮） | `{ view: "SETTINGS" }` | 打开模态框并渲染“设置”视图。 |

#### 4.4.2 状态处置与视图渲染 (State & View Routing)

模态框内部维护一个视图路由 (`currentView`)，根据引擎状态 (`fsm.currentState`) 或用户操作切换显示内容。

**核心交互流程**:
1.  **App Start** -> `LOGIN` 状态 -> 显示 **登录视图**。
2.  **Login Success** -> `MAIN_MENU` 状态 -> 显示 **主菜单视图**。
3.  **Select Level** -> `BATTLE_PREPARE` 状态 -> **关闭模态框** (进入战斗界面)。
4.  **In Battle** -> 用户点击暂停 -> 显示 **暂停/菜单视图**。

**详细视图定义**:

1.  **Login (登录/欢迎页)**
    *   **触发**: `STATE_CHANGED` -> `LOGIN`.
    *   **内容**:
        *   游戏标题 (Logo).
        *   用户输入框 (`input`): 输入玩家名称。
        *   确认按钮 ("开始冒险"): 点击触发 `Engine.input.login(username)`.
    *   **约束**: 此时不可关闭模态框。

2.  **Main Menu (主菜单)**
    *   **触发**: `STATE_CHANGED` -> `MAIN_MENU` 或 用户点击“系统菜单”按钮。
    *   **内容**:
        *   "继续游戏": 仅当从暂停进入或有中断的战斗存档时显示。
        *   "关卡选择": 切换至 Level Select 视图。
        *   "存档 / 读档": 切换至 Save/Load 视图。
        *   "设置": 切换至 Settings 视图。
        *   "注销": 调用 `backToTitle` 返回登录页。

3.  **Level Select (关卡选择)**
    *   **触发**: 从主菜单进入。
    *   **数据源**: `DataManager.getLevels()`.
    *   **渲染**: 关卡卡片列表。
    *   **交互**: 点击卡片 -> 调用 `Engine.input.selectLevel(id)`。
    *   **注意**: 引擎接收指令后会切换状态至 `BATTLE_PREPARE`，模态框监听到状态变化后应自动隐藏。

4.  **Save/Load (存档/读档)**
    *   **触发**: 从主菜单进入。
    *   **数据源**: `DataManager.getSaveList()`.
    *   **渲染**: 显示存档槽位。每个槽位包含“保存”和“读取”按钮。

#### 4.4.3 发送指令 (Modal -> Engine)

模态框内的操作通常对应引擎的全局方法：

| 接口名称 | 参数结构 | 说明 |
| :--- | :--- | :--- |
| `Engine.input.login(username)` | `username: string` | 玩家在登录页点击开始。引擎加载用户数据并切换至 `MAIN_MENU`。 |
| `Engine.input.selectLevel(levelId)` | `levelId: string` | 玩家点击关卡卡片。引擎加载关卡并切换至 `BATTLE_PREPARE`。 |
| `Engine.input.saveGame(slotId)` | `slotId: number` | 玩家点击“保存”。 |
| `Engine.input.loadGame(slotId)` | `slotId: number` | 玩家点击“读取”。 |
| `Engine.input.resumeGame()` | `null` | 玩家点击“继续游戏”或关闭模态框。 |
| `Engine.input.backToTitle()` | `null` | 玩家点击“注销”。引擎切换状态至 `LOGIN`。 |

### 4.5 战斗主体行接口详解 (Battle Row Interface)

战斗主体行 (`.battle-row`) 是战斗画面的核心区域，包含玩家状态 (`PlayerHUD`)、战斗场景 (`BattleScene`) 和敌人状态 (`EnemyHUD`)。

#### 4.5.1 监听事件 (Engine -> Battle Row)

该模块主要监听战斗循环中的状态更新事件：

| 事件名称 | 触发时机 | 数据结构示例 | 处置逻辑 |
| :--- | :--- | :--- | :--- |
| `BATTLE_START` | 战斗初始化时 | `{ player: {...}, level: {...} }` | 初始化玩家和敌人的 HUD，加载场景背景和角色立绘。 |
| `BATTLE_UPDATE` | 任何战斗数据变更时 | `{ player: {...}, enemies: [...], turn: 1, phase: "PLANNING" }` | 全量或增量更新 HP/AP 条、护甲状态、Buff 图标。 |
| `TURN_START` | 回合开始时 | `{ turn: 2 }` | (可选) 显示回合开始特效，重置临时状态显示。 |
| `BATTLE_LOG` | 发生战斗行为时 | `{ text: "...", action: {...}, result: {...} }` | 在角色头顶显示飘字 (Damage Text) 或播放受击特效。 |

#### 4.5.2 状态处置与视图渲染

战斗主体行通常由三个子组件协同工作，它们共享上述事件数据，但关注点不同。

1.  **Player HUD (玩家状态)**
    *   **数据源**: `data.player`.
    *   **渲染**:
        *   **HP/AP Bar**: 根据 `current / max` 计算百分比宽度。
        *   **Armor List**: 遍历 `bodyParts` 或 `equipment`，渲染各部位护甲值。若护甲为 0，添加 `.broken` 样式。
        *   **Buffs**: 渲染状态图标列表。

2.  **Enemy HUD (敌人状态)**
    *   **数据源**: `data.enemies` (通常取第一个或当前选中的敌人).
    *   **渲染**: 与 Player HUD 类似。若有多个敌人，需根据 `SelectedTarget` 切换显示或显示列表。

3.  **Battle Scene (战斗场景)**
    *   **数据源**: `data.player` & `data.enemies`.
    *   **渲染**:
        *   **立绘**: 根据 ID 加载对应图片。
        *   **状态反馈**: 若单位死亡 (`hp <= 0`)，添加灰度或淡出效果。
        *   **特效**: 监听 `BATTLE_LOG` 中的 `action` 和 `result`，在对应位置播放动画（如攻击动作、受击闪烁）。

#### 4.5.3 发送指令 (Battle Row -> Engine)

目前设计中，战斗主体行主要作为 **纯展示模块 (View-Only)**，不直接向引擎发送指令。
所有的交互操作（如选择技能、切换目标）均由 **技能面板 (.skill-panel)** 或其他控制模块处理。

## 5. 代码设计规范

为了保证 UI 系统的可维护性与扩展性，所有 UI 模块的开发需遵循以下规范：

### 5.1 模块化设计
*   **独立性**: 每个 UI 模块（如 `PlayerHUD`, `SkillPanel`, `SystemModal`）应设计为独立的组件类或闭包。
*   **可测试性**: 组件应具备独立的初始化与销毁方法，能够在不依赖完整游戏环境的情况下进行单元测试或 Storybook 式的视觉测试。

### 5.2 注释与文档
*   **接口说明**: 所有公共方法（Public Methods）和事件监听器必须包含详细的 JSDoc 注释，说明参数结构、返回值及副作用。
*   **逻辑注释**: 复杂的交互逻辑（如拖拽排序、状态映射）需在代码块前添加简要说明。

### 5.3 文件命名规范
*   **统一前缀**: 所有 UI 组件文件应存放在 `script/ui/` 目录下，并统一以 `UI_` 开头，例如：
    *   `UI_PlayerHUD.js`
    *   `UI_SkillPanel.js`
    *   `UI_SystemModal.js`
    *   `UI_BattleScene.js`
*   **样式分离**: 若组件有私有样式，建议使用同名 CSS 文件或在统一的 CSS 文件中使用 BEM 命名法（如 `.ui-player-hud__bar`）。

### 5.4 驱动代码分离 (Decoupling)
*   **逻辑分离**: UI 组件只负责 **“显示数据”** 和 **“捕获输入”**。
    *   **禁止**: 在 UI 代码中直接修改引擎的核心数据（如直接修改 `player.hp`）。
    *   **推荐**: 通过 `Engine.input` 接口发送指令，等待引擎处理后通过事件更新视图。
*   **避免耦合**: UI 组件不应持有 `Engine` 的完整实例引用，仅持有必要的 `EventBus` 或 `InputProxy` 引用。

### 5.5 组件间通信
*   **禁止直接通信**: 不同 UI 组件之间（例如 `SkillPanel` 和 `PlayerHUD`）严禁直接调用对方的方法或修改对方的 DOM。
*   **统一管理**:
    *   若需联动（如选择技能时高亮目标），应通过 **引擎事件** 中转。
    *   或者由一个父级控制器（`UIManager`）统一协调子组件的状态。

