import EventBus from './EventBus.js';
import GameFSM from './GameFSM.js';
import GameLoop from './GameLoop.js';
import DataManager from './DataManagerV2.js';
import { BuffRegistry, BuffManager, BuffSystem } from './buff/index.js';
import TurnPlanner from './TurnPlanner.js';
import TimelineManager from './TimelineManager.js';

class CoreEngine {
    constructor() {
        this.eventBus = EventBus;
        this.fsm = GameFSM;
        this.loop = GameLoop;
        this.data = DataManager;

		this.buffRegistry = new BuffRegistry();
		this.buffSystem = new BuffSystem(this.eventBus, this.buffRegistry);

        this.turnPlanner = new TurnPlanner({
            getSlotLayout: () => this._getBattleSlotLayout(),
            getPlayerId: () => (this.data && this.data.playerData ? this.data.playerData.id : null),
            getSkillConfig: (skillId) => this.data.getSkillConfig(skillId),
            getCurrentAp: () => (this.data && this.data.playerData && this.data.playerData.stats ? this.data.playerData.stats.ap : 0),
            getUsedAp: () => (this.playerSkillQueue || []).reduce((sum, a) => sum + (Number(a.cost) || 0), 0)
        });

        this.timeline = new TimelineManager({
            eventBus: this.eventBus,
            executeEntry: async (entry) => this._executeTimelineEntry(entry)
        });
        
        this.input = {
            login: this.login.bind(this),
            selectLevel: this.selectLevel.bind(this),
            addSkillToQueue: this.addSkillToQueue.bind(this),
            removeSkillFromQueue: this.removeSkillFromQueue.bind(this),
         assignSkillToSlot: this.assignSkillToSlot.bind(this),
            unassignSlot: this.unassignSlot.bind(this),
            commitPlanning: this.commitPlanning.bind(this),
            commitTurn: this.commitTurn.bind(this),
            saveGame: this.saveGame.bind(this),
            loadGame: this.loadGame.bind(this),
            resumeGame: this.resumeGame.bind(this),
            backToTitle: this.backToTitle.bind(this),
            resetTurn: this.resetTurn.bind(this),
            confirmSettlement: this.confirmSettlement.bind(this),
            learnSkill: this.learnSkill.bind(this)
        };

        this.playerSkillQueue = [];
        this.enemySkillQueue = [];
        this.battlePhase = 'IDLE'; // IDLE, PLANNING, EXECUTION

        this._bindTimelineEvents();

        this._battleSlotLayout = null;

        this.init();
    }

    _buildEffectiveApCostBySkill(skillIds) {
        const out = Object.create(null);
        const ids = Array.isArray(skillIds) ? skillIds : [];
        for (const id of ids) {
            const cfg = this.data.getSkillConfig(id);
            if (!cfg) continue;
            // Current stage: treat cost as stable during PLANNING.
            // Future: apply buff-adjusted modifiers here once, at PLANNING_ENTER.
            out[id] = Number(cfg.cost) || 0;
        }
        return out;
    }

    _buildEffectiveApCostForAllSkills() {
        const root = this.data?.gameConfig?.skills;
        if (!root || typeof root !== 'object') return Object.create(null);
        const ids = Object.keys(root);
      const out = Object.create(null);
        for (const id of ids) {
            const cfg = this.data.getSkillConfig(id);
            if (!cfg) continue;
            out[id] = this._getSkillApCostStrict(cfg, id);
        }
        return out;
    }

    _getSkillApCostStrict(skillConfig, skillIdForLog = null) {
        const ap = Number(skillConfig?.costs?.ap);
        if (!Number.isFinite(ap) || ap < 0) {
            const name = skillConfig?.name ? ` (${skillConfig.name})` : '';
            const id = skillIdForLog || skillConfig?.id || 'unknown';
            throw new Error(`[CoreEngine] Invalid skill AP cost: skillId=${id}${name}. Expected skill.costs.ap number.`);
        }
        return ap;
    }

    _enterPlanningBudgetSnapshot() {
        const availableAp = Number(this.data?.playerData?.stats?.ap ?? 0) || 0;
      // Important: UI may present skills not strictly limited to `player.skills.learned`
        // (e.g. mock UI static buttons / debug injection). To keep the planning budget
        // consistent, build a cost map that covers all known skills.
        const effectiveApCostBySkill = this._buildEffectiveApCostForAllSkills();
        if (!effectiveApCostBySkill || Object.keys(effectiveApCostBySkill).length === 0) {
            this.eventBus.emit('BATTLE_LOG', { text: 'Planning init warning: effectiveApCostBySkill is empty (skills not loaded?)' });
        }
        const res = this.turnPlanner.enterPlanning({ availableAp, effectiveApCostBySkill });
        if (!res.ok) {
            this.eventBus.emit('BATTLE_LOG', { text: `Planning init failed: ${res.reason || 'unknown'}` });
        }
    }

    _bindTimelineEvents() {
        if (!this.eventBus || typeof this.eventBus.on !== 'function') {
            throw new Error('[CoreEngine] EventBus must support .on(event, handler).');
        }

        this.eventBus.on('TIMELINE_FINISHED', ({ roundId } = {}) => {
            if (this.fsm.currentState !== 'BATTLE_LOOP') return;
            if (this.battlePhase !== 'EXECUTION') return;
            if (roundId !== this.timeline.roundId) return;

            // Turn end hooks (DoT / duration tick)
            this.eventBus.emit('TURN_END', { turn: this.currentTurn });
            this.startTurn();
        });

        this.eventBus.on('TIMELINE_ERROR', ({ message, details } = {}) => {
            if (this.fsm.currentState !== 'BATTLE_LOOP') return;
            if (this.battlePhase !== 'EXECUTION') return;

            this.eventBus.emit('BATTLE_LOG', { text: `Timeline execute failed: ${message}` });
            this.emitBattleUpdate();
        });
    }

    // ----------------- Battle Rules: Slot Layout -----------------

    _getSlotLayoutsRoot() {
        return (this.data && this.data.gameConfig) ? this.data.gameConfig.slotLayouts : null;
    }

    _resolveSlotLayoutIdForCurrentBattle() {
        const levelId = this.data && this.data.currentLevelData ? this.data.currentLevelData.id : null;
        const levelCfg = levelId && this.data.gameConfig && this.data.gameConfig.levels ? this.data.gameConfig.levels[levelId] : null;
        const fromLevel = levelCfg && levelCfg.battleRules ? levelCfg.battleRules.slotLayoutId : null;
        const fromConfig = (this.data && this.data.dataConfig && this.data.dataConfig.battleRules)
            ? this.data.dataConfig.battleRules.slotLayoutId
            : null;
        const fromSourcesConfig = (this.data && this.data._dataSourcesVersion) // keep method side-effect free
            ? null
            : null;

        return fromLevel || fromConfig || 'default_v1';
    }

    _getBattleSlotLayout() {
        if (this._battleSlotLayout) return this._battleSlotLayout;

        const root = this._getSlotLayoutsRoot();
        const layoutId = this._resolveSlotLayoutIdForCurrentBattle();
        const layout = root && root.layouts ? root.layouts[layoutId] : null;
        this._battleSlotLayout = layout || null;
        return this._battleSlotLayout;
    }

    _getSlotCapacity(side, bodyPart) {
        const layout = this._getBattleSlotLayout();
        if (!layout || !layout.slotCounts) return Infinity;
        const row = layout.slotCounts[bodyPart];
        const cap = row && row[side] !== undefined ? Number(row[side]) : Infinity;
        return Number.isFinite(cap) ? cap : Infinity;
    }

    _getUsedSlotsCount(queue, side, bodyPart) {
        return (queue || []).filter(a => {
            const isSelf = (a.targetId === this.data.playerData.id);
            const aSide = isSelf ? 'self' : 'enemy';
            return aSide === side && a.bodyPart === bodyPart;
        }).length;
    }

    learnSkill(skillId) {
        const player = this.data.playerData;
        if (!player) return;
        if (!player.skills || typeof player.skills !== 'object') player.skills = {};
        if (!Array.isArray(player.skills.learned)) player.skills.learned = [];
        if (typeof player.skills.skillPoints !== 'number') player.skills.skillPoints = 0;

        const def = (this.data.gameConfig && this.data.gameConfig.skills) ? this.data.gameConfig.skills[skillId] : null;
        if (!def) {
            console.warn('[CoreEngine] learnSkill: skill not found:', skillId);
            return;
        }

        if (player.skills.learned.includes(skillId)) return;

        const prereqs = Array.isArray(def.prerequisites) ? def.prerequisites : [];
        const missing = prereqs.filter(p => !player.skills.learned.includes(p));
        if (missing.length > 0) {
            console.warn('[CoreEngine] learnSkill: missing prerequisites:', missing);
            return;
        }

        const cost = Number(def?.unlock?.cost?.kp) || 0;
        if (player.skills.skillPoints < cost) {
            console.warn('[CoreEngine] learnSkill: insufficient KP');
            return;
        }

        const exclusives = Array.isArray(def?.unlock?.exclusives) ? def.unlock.exclusives : [];
        if (exclusives.some(x => player.skills.learned.includes(x))) {
            console.warn('[CoreEngine] learnSkill: exclusive lock');
            return;
        }

        player.skills.skillPoints -= cost;
        player.skills.learned.push(skillId);

        this.eventBus.emit('DATA_UPDATE', { type: 'PLAYER_SKILLS', data: player.skills });
        this.data.saveGame();
    }

    async init() {
        console.log('Engine initializing...');
        this.fsm.changeState('INIT');
        
        await this.data.loadConfigs();
		this.buffRegistry.setDefinitions((this.data.gameConfig && this.data.gameConfig.buffs) ? this.data.gameConfig.buffs : {});
		this.buffSystem.start();
        
        this.loop.start();
        
        // 初始化后自动跳转到登录状态
        this.fsm.changeState('LOGIN');
        console.log('Engine initialized.');
    }

    // --- 输入处理程序 ---

    login(username) {
        if (this.fsm.currentState !== 'LOGIN') return;

        console.log(`User logging in: ${username}`);
        // 尝试先加载现有游戏
        if (!this.data.loadGame()) {
            this.data.createNewGame(username);
        }
        
        // 统一行为：登录后总是进入主菜单
        // 仅切换状态，具体显示逻辑（如是否显示“继续游戏”）由 UI 层根据数据决定
        this.fsm.changeState('MAIN_MENU');
        this.eventBus.emit('DATA_UPDATE', this.data.playerData);
    }

    // 强制创建新游戏，覆盖现有存档
    resetGame(username) {
        console.log(`Resetting game for user: ${username}`);
        this.data.createNewGame(username);
        
        // 如果我们在登录状态，转换到主菜单
        // 如果我们已经在游戏中，只需更新数据
        if (this.fsm.currentState === 'LOGIN') {
            this.fsm.changeState('MAIN_MENU');
        }
        
        this.eventBus.emit('DATA_UPDATE', this.data.playerData);
        this.eventBus.emit('BATTLE_LOG', { text: 'Game has been reset. New game started.' });
    }

    selectLevel(levelId) {
        if (this.fsm.currentState !== 'MAIN_MENU' && this.fsm.currentState !== 'LEVEL_SELECT') return;

        const levelData = this.data.instantiateLevel(levelId);
        if (!levelData) {
            console.error('Level not found:', levelId);
            return;
        }

        console.log(`Level selected: ${levelId}`);
        this.data.currentLevelData = levelData;
        this.fsm.changeState('BATTLE_PREPARE');
        
        // 暂时模拟立即进入战斗
        setTimeout(() => {
            this.startBattle();
        }, 500);
    }

    startBattle() {
        // Ensure BuffManager exists for player
        if (this.data.playerData) {
			if (!this.data.playerData.buffs) {
				this.data.playerData.buffs = new BuffManager(this.data.playerData, this.buffRegistry, this.eventBus);
				this.buffSystem.registerManager(this.data.playerData.buffs);
			}
		}

        // Reset Player State at start of battle (Design 3.3)
        if (this.data.playerData) {
            const p = this.data.playerData;
            // 1. Reset Stats
            if (p.stats) {
                p.stats.hp = p.stats.maxHp;
                p.stats.ap = p.stats.maxAp;
            }
            // 2. Reset Body Parts (Base)
            if (p.bodyParts) {
                for (const key in p.bodyParts) {
                    const part = p.bodyParts[key];
                    part.current = part.max || 0;
                    part.status = 'NORMAL';
                }
            }
            this.eventBus.emit('DATA_UPDATE', p);
        }

        this.currentTurn = 0;
        this.fsm.changeState('BATTLE_LOOP');
        
        // 初始化运行时数据结构
        if (!this.data.dataConfig.runtime) this.data.dataConfig.runtime = {};
        const runtime = this.data.dataConfig.runtime;

        // 1. 初始状态快照
        runtime.initialState = {
            enemies: JSON.parse(JSON.stringify(this.data.currentLevelData.enemies))
        };

        // 2. 历史记录
        runtime.history = [];

        // 3. 队列
        runtime.queues = {
            player: [],
            enemy: []
        };

        // 3.2 Planning state (slot-key based)
        runtime.planning = {
            player: {
                assigned: {},
                actionsById: {},
                order: [],
                skillCounts: {}
            }
        };

        // 3.1 Battle rules snapshot (slots)
        runtime.battleRules = runtime.battleRules || {};
        const slotLayoutId = this._resolveSlotLayoutIdForCurrentBattle();
        runtime.battleRules.slotLayoutId = slotLayoutId;
        const layoutRoot = this._getSlotLayoutsRoot();
        runtime.battleRules.slotLayout = (layoutRoot && layoutRoot.layouts && layoutRoot.layouts[slotLayoutId])
            ? JSON.parse(JSON.stringify(layoutRoot.layouts[slotLayoutId]))
            : null;

        this._battleSlotLayout = runtime.battleRules.slotLayout;

        // 4. 玩家临时状态
        runtime.playerBattleState = {
            buffs: [],
            tempStatModifiers: {},
            bodyParts: this.initializePlayerBodyParts(this.data.playerData)
        };

        const playerWithRuntime = {
            ...this.data.playerData,
            bodyParts: runtime.playerBattleState.bodyParts
        };

        this.eventBus.emit('BATTLE_START', { 
            player: playerWithRuntime, 
            level: this.data.currentLevelData 
        });

		// Ensure BuffManager exists for enemies
		if (this.data.currentLevelData && Array.isArray(this.data.currentLevelData.enemies)) {
			for (const enemy of this.data.currentLevelData.enemies) {
				if (!enemy.buffs) {
					enemy.buffs = new BuffManager(enemy, this.buffRegistry, this.eventBus);
					this.buffSystem.registerManager(enemy.buffs);
				}
			}
		}

        this.startTurn();
    }

    initializePlayerBodyParts(playerData) {
        // 1. Define standard 5 body parts
        const partNames = ['head', 'chest', 'abdomen', 'arm', 'leg'];
        let bodyParts = {};

        // Use defined bodyParts if available, deep copy to avoid mutation
        if (playerData.bodyParts) {
            bodyParts = JSON.parse(JSON.stringify(playerData.bodyParts));
        }

        // Ensure all parts exist and set defaults if missing
        partNames.forEach(name => {
            if (!bodyParts[name]) {
                bodyParts[name] = {
                    current: 0,
                    max: 0,
                    weakness: 1.0, 
                    status: 'NORMAL'
                };
                
                // Apply default weaknesses for generated parts
                if (name === 'head') bodyParts[name].weakness = 1.5;
                if (name === 'abdomen') bodyParts[name].weakness = 1.1;
            } else {
                 // Ensure fields
                 if (bodyParts[name].current === undefined) bodyParts[name].current = 0;
                 if (bodyParts[name].max === undefined) bodyParts[name].max = 0;
                 if (bodyParts[name].weakness === undefined) bodyParts[name].weakness = 1.0;
                 if (!bodyParts[name].status) bodyParts[name].status = 'NORMAL';
            }
        });

        // 2. Apply Equipment Buffs (Add on top of base values)
        if (playerData.equipment && this.data.gameConfig && this.data.gameConfig.items) {
            for (const [slot, itemId] of Object.entries(playerData.equipment)) {
                if (!itemId) continue;

                // Lookup item config
                const item = this.data.gameConfig.items[itemId];
                if (!item || !item.buffs) continue;

                // Process passive buffs (duration = -1)
                item.buffs.forEach(buff => {
                    if (buff.type === 'BUFF' && buff.effect === 'STAT_MOD' && buff.duration === -1) {
                        // Handle armor stats (e.g., "armor_head")
                        if (buff.stat && buff.stat.startsWith('armor_')) {
                            const partName = buff.stat.replace('armor_', '');
                            if (bodyParts[partName]) {
                                bodyParts[partName].max += buff.value;
                                bodyParts[partName].current += buff.value;
                            }
                        }
                        // Note: Other stats like attack/speed would be handled by a global stat manager,
                        // effectively modifying the player's runtime stats, not body parts.
                    }
                });
            }
        }
        
        return bodyParts;
    }

    resumeBattle() {
        const runtime = this.data.dataConfig.runtime;
        this.currentTurn = runtime.turn || 1;
        this.battlePhase = runtime.phase || 'PLANNING';

		// Ensure BuffManager exists for player after load
		if (this.data.playerData && !this.data.playerData.buffs) {
			this.data.playerData.buffs = new BuffManager(this.data.playerData, this.buffRegistry, this.eventBus);
			this.buffSystem.registerManager(this.data.playerData.buffs);
		}
        
        // 恢复队列
        this.playerSkillQueue = runtime.queues ? (runtime.queues.player || []) : [];
        this.enemySkillQueue = runtime.queues ? (runtime.queues.enemy || []) : [];

        this.fsm.changeState('BATTLE_LOOP');
        
        // Prepare player object with runtime body parts
        const playerWithRuntime = {
            ...this.data.playerData,
            bodyParts: (runtime.playerBattleState) ? runtime.playerBattleState.bodyParts : {}
        };

        this.eventBus.emit('BATTLE_START', { 
            player: playerWithRuntime, 
            level: this.data.currentLevelData 
        });
        
        console.log(`Resumed battle at Turn ${this.currentTurn}, Phase ${this.battlePhase}`);
        
        // 如果是在执行阶段恢复，可能需要继续执行或重新开始回合逻辑
        // 为了简单，如果是在执行阶段恢复，强制重置为规划阶段
        // 或者如果是结算后，只是恢复 UI 状态。
        
        this.emitBattleUpdate();
        this.eventBus.emit('BATTLE_LOG', { text: `Game Resumed. Turn ${this.currentTurn}.` });
    }

    resumeGame() {
        console.log('Resume Game requested.');
        if (this.fsm.currentState === 'MAIN_MENU') {
             if (this.data.dataConfig.runtime && this.data.dataConfig.runtime.levelData) {
                this.resumeBattle();
             } else {
                 console.warn('No saved battle to resume.');
             }
        } else if (this.fsm.currentState === 'BATTLE_LOOP' || this.fsm.currentState === 'BATTLE_PREPARE') {
            // Just close modal, handled by UI usually, but engine can emit event
            this.eventBus.emit('UI:CLOSE_MODAL');
        }
    }

    backToTitle() {
        console.log('Returning to title...');
        this.fsm.changeState('LOGIN');
        // Reset runtime data if needed, but keep global config?
        // For now, just switch state.
    }

    confirmSettlement() {
        if (this.fsm.currentState !== 'BATTLE_SETTLEMENT') return;
        console.log('Confirming settlement, returning to menu...');
        this.fsm.changeState('MAIN_MENU');
    }

    loadGame(slotId) {
        console.log(`Loading game (slot ${slotId})...`);
        if (this.data.loadGame(slotId)) {
            this.eventBus.emit('DATA_UPDATE', this.data.playerData);
            
            // Check if we should resume a battle
            if (this.data.dataConfig.runtime && this.data.dataConfig.runtime.levelData) {
                this.resumeBattle();
            } else {
                this.fsm.changeState('MAIN_MENU');
            }
        } else {
            this.eventBus.emit('BATTLE_LOG', { text: 'Failed to load game.' });
        }
    }

    saveGame(slotId) {
        // 保存前将当前战斗状态同步到 DataManager
        if (this.fsm.currentState === 'BATTLE_LOOP') {
            this.saveBattleState();
        } else {
            // 如果不在战斗中，清除战斗运行时数据
            if (this.data.dataConfig.runtime) {
                delete this.data.dataConfig.runtime.levelData;
                delete this.data.dataConfig.runtime.turn;
                delete this.data.dataConfig.runtime.phase;
                delete this.data.dataConfig.runtime.initialState;
                delete this.data.dataConfig.runtime.history;
                delete this.data.dataConfig.runtime.queues;
                delete this.data.dataConfig.runtime.playerTempState;
            }
            this.data.currentLevelData = null;
        }
        
        this.data.saveGame();
        this.eventBus.emit('BATTLE_LOG', { text: 'Game Saved.' });
    }

    startTurn() {
        this.currentTurn++;
        console.log('Turn Started: ' + this.currentTurn);
        
        this.battlePhase = 'PLANNING';
        
        // 记录历史快照
        if (this.data.dataConfig.runtime) {
            if (!this.data.dataConfig.runtime.history) this.data.dataConfig.runtime.history = [];
            
            const snapshot = {
                player: { 
                    hp: this.data.playerData.stats.hp, 
                    ap: this.data.playerData.stats.ap 
                },
                enemies: this.data.currentLevelData.enemies.map(e => ({
                    id: e.id,
                    hp: e.hp,
                    pos: e.position || 0
                }))
            };

            this.currentHistoryEntry = {
                turn: this.currentTurn,
                timestamp: Date.now(),
                seed: 'mock_seed_' + Date.now(),
                snapshot: snapshot,
                systemEvents: [],
                actions: []
            };
            this.data.dataConfig.runtime.history.push(this.currentHistoryEntry);
        }

        this.saveBattleState();

        this.playerSkillQueue = [];
        this.enemySkillQueue = [];
        this.turnPlanner.reset();
        this.timeline.reset();
        this._syncPlannerToRuntime();

        // 重置 AP
        if (this.data.playerData) {
            this.data.playerData.stats.ap = this.data.playerData.stats.maxAp;
            this.eventBus.emit('DATA_UPDATE', this.data.playerData);
        }

        // Planning-enter snapshot: initialize AP budget FSM once per planning phase.
        this._enterPlanningBudgetSnapshot();

        this.eventBus.emit('TURN_START', { turn: this.currentTurn });
        this.emitBattleUpdate();
        this.eventBus.emit('BATTLE_LOG', { text: `Turn ${this.currentTurn} started. Please configure skills.` });
    }

    addSkillToQueue(skillId, targetId, bodyPart) {
        if (this.fsm.currentState !== 'BATTLE_LOOP' || this.battlePhase !== 'PLANNING') return;

        const player = this.data.playerData;
        const skillConfig = this.data.getSkillConfig(skillId);
        
        if (!skillConfig) {
            this.eventBus.emit('BATTLE_LOG', { text: `Unknown skill: ${skillId}` });
            return;
        }

        // 验证目标身体部位
        // 攻击和辅助技能需要身体部位，除非它们是全局/AOE
        const requiresBodyPart = (skillConfig.type === 'DAMAGE' || skillConfig.type === 'HEAL' || skillConfig.type === 'BUFF') && skillConfig.targetType !== 'GLOBAL' && skillConfig.targetType !== 'AOE';

        if (requiresBodyPart) {
            if (!bodyPart) {
                this.eventBus.emit('BATTLE_LOG', { text: `Skill ${skillConfig.name} requires a target body part.` });
                return;
            }

            // 查找目标
            let target = null;
            if (targetId === this.data.playerData.id) {
                target = this.data.playerData;
            } else if (this.data.currentLevelData && this.data.currentLevelData.enemies) {
                target = this.data.currentLevelData.enemies.find(e => e.id === targetId);
            }

            if (!target) {
                this.eventBus.emit('BATTLE_LOG', { text: `Invalid target: ${targetId}` });
                return;
            }

            // 检查目标是否存在身体部位
            let isValidPart = false;
            if (target.bodyParts) {
                // 具有明确身体部位的敌人
                if (target.bodyParts[bodyPart]) isValidPart = true;
            } else if (target.equipment && target.equipment.armor) {
                // 玩家（使用护甲槽作为身体部位）
                if (target.equipment.armor.hasOwnProperty(bodyPart)) isValidPart = true;
            }

            if (!isValidPart) {
                this.eventBus.emit('BATTLE_LOG', { text: `Invalid body part '${bodyPart}' for target.` });
                return;
            }
        }

        const cost = this._getSkillApCostStrict(skillConfig, skillId);

        // Slot capacity validation (core mechanic)
        const isSelfTarget = (targetId === this.data.playerData.id);
        const side = isSelfTarget ? 'self' : 'enemy';
        const capacity = this._getSlotCapacity(side, bodyPart);
        const used = this._getUsedSlotsCount(this.playerSkillQueue, side, bodyPart);
        if (used >= capacity) {
            this.eventBus.emit('BATTLE_LOG', { text: `No available slot for ${side}:${bodyPart} (capacity ${capacity}).` });
            return;
        }

        // 计算当前 AP 使用量
        const currentQueueCost = this.playerSkillQueue.reduce((sum, action) => sum + action.cost, 0);
        if (player.stats.ap < currentQueueCost + cost) {
            this.eventBus.emit('BATTLE_LOG', { text: `Not enough AP! Cannot add more skills.` });
            return;
        }

        const skillAction = {
            source: 'PLAYER',
            skillId,
            targetId,
            bodyPart,
            cost,
            speed: (player.stats.speed || 10) + (skillConfig.speed || 0)
        };
        this.playerSkillQueue.push(skillAction);
        
        this.eventBus.emit('BATTLE_LOG', { text: `Added skill: ${skillConfig.name} (Cost: ${cost} AP)` });
        this.emitBattleUpdate();
    }

    // slotKey-based planning API
    assignSkillToSlot({ slotKey, skillId, targetId, bodyPart, replaceIfAlreadyPlaced = true }) {
        if (this.fsm.currentState !== 'BATTLE_LOOP' || this.battlePhase !== 'PLANNING') return;

        const skillConfig = this.data.getSkillConfig(skillId);
        if (!skillConfig) {
            this.eventBus.emit('BATTLE_LOG', { text: `Unknown skill: ${skillId}` });
            return;
        }

        // reuse old validations (target/body part)
        const requiresBodyPart = (skillConfig.type === 'DAMAGE' || skillConfig.type === 'HEAL' || skillConfig.type === 'BUFF') && skillConfig.targetType !== 'GLOBAL' && skillConfig.targetType !== 'AOE';
        if (requiresBodyPart && !bodyPart) {
            this.eventBus.emit('BATTLE_LOG', { text: `Skill ${skillConfig.name} requires a target body part.` });
            return;
        }

        const cost = this._getSkillApCostStrict(skillConfig, skillId);
        const speed = (this.data.playerData.stats.speed || 10) + (skillConfig.speed || 0);

        const res = this.turnPlanner.assign({
            slotKey,
            skillId,
            targetId,
            bodyPart,
            cost,
            speed,
            replaceIfAlreadyPlaced
        });

        if (!res.ok) {
            this.eventBus.emit('BATTLE_LOG', { text: res.reason || 'Cannot assign to slot.' });
            return;
        }

        this._freezePlannerToQueue();
        this._syncPlannerToRuntime();
        this.eventBus.emit('BATTLE_LOG', { text: `Placed skill: ${skillConfig.name}` });
        this.emitBattleUpdate();
    }

    // Draft-first planning API (batch commit)
    commitPlanning({ planningDraftBySkill }) {
        if (this.fsm.currentState !== 'BATTLE_LOOP' || this.battlePhase !== 'PLANNING') return;

        const drafts = planningDraftBySkill && typeof planningDraftBySkill === 'object'
            ? Object.values(planningDraftBySkill)
            : [];

        const normalized = Object.create(null);
       const apBudget = this.turnPlanner?.getApBudgetState ? this.turnPlanner.getApBudgetState() : null;
        for (const d of drafts) {
            if (!d || !d.skillId) continue;

            const skillConfig = this.data.getSkillConfig(d.skillId);
            if (!skillConfig) {
                this.eventBus.emit('BATTLE_LOG', { text: `Unknown skill: ${d.skillId}` });
                this.eventBus.emit('PLANNING_COMMIT_FAILED', { reason: `Unknown skill: ${d.skillId}`, skillId: d.skillId });
                return;
            }

            const cost = Number(apBudget?.effectiveApCostBySkill?.[d.skillId]);
            if (!Number.isFinite(cost)) {
                // Strict mode: AP budget snapshot must provide cost for all skills.
                // If missing, treat as hard data/config error.
                throw new Error(`[CoreEngine] Missing effective AP cost for skillId=${d.skillId} (planning budget not initialized correctly).`);
            }
            const speed = (this.data.playerData.stats.speed || 10) + (Number(skillConfig.speed) || 0);
            normalized[d.skillId] = {
                ...d,
                cost,
                speed
            };
        }

        const res = this.turnPlanner.planMany({ planningDraftBySkill: normalized });
        if (!res.ok) {
            const reason = Array.isArray(res.errors) && res.errors.length > 0
                ? (res.errors[0].reason || 'Cannot commit planning.')
                : (res.reason || 'Cannot commit planning.');
            this.eventBus.emit('BATTLE_LOG', { text: reason });
            this.eventBus.emit('PLANNING_COMMIT_FAILED', { reason, errors: res.errors || [] });
            return;
        }

        // Dev-only visibility: print submitted planning input/output to console for verification.
        try {
            const safeNormalized = JSON.parse(JSON.stringify(normalized));
            const planned = this.turnPlanner.getPlannedActions();
            const safePlanned = JSON.parse(JSON.stringify(planned));
            console.groupCollapsed('[Planning Commit]');
            console.log('input.planningDraftBySkill(normalized)=', safeNormalized);
            console.log('output.plannedActions=', safePlanned);
            console.groupEnd();
        } catch (e) {
            console.log('[Planning Commit] (log failed)', e);
        }

        this._freezePlannerToQueue();
        this._syncPlannerToRuntime();

        // Build timeline immediately so UI can preview the round order after planning commit.
        // This keeps "提交规划" (commit) decoupled from "执行" (playback).
        this.enemySkillQueue = [];
        if (this.data.currentLevelData && this.data.currentLevelData.enemies) {
            this.data.currentLevelData.enemies.forEach(enemy => {
                if (enemy.hp > 0) {
                    const skillId = (enemy.skills && enemy.skills.length > 0) ? enemy.skills[0] : 'skill_bite';
                    const skillConfig = this.data.getSkillConfig(skillId);
                    const speed = (enemy.speed || 10) + (skillConfig ? skillConfig.speed : 0);
                    this.enemySkillQueue.push({
                        source: 'ENEMY',
                        sourceId: enemy.id,
                        skillId: skillId,
                        targetId: this.data.playerData.id,
                        cost: 0,
                        speed: speed
                    });
                }
            });
        }

        const loadRes = this.timeline.loadRoundActions({
            roundId: this.currentTurn,
            selfPlans: this.playerSkillQueue,
            enemyPlans: this.enemySkillQueue,
            rules: { tieBreak: 'selfFirst' }
        });

        if (!loadRes.ok) {
            this.eventBus.emit('BATTLE_LOG', { text: `Timeline build failed: ${loadRes.reason}` });
            // Fail-fast: do not continue with an inconsistent preview state.
            return;
        }

        this.eventBus.emit('PLANNING_COMMITTED', {
            planningDraftBySkill: JSON.parse(JSON.stringify(normalized)),
            plannedActions: JSON.parse(JSON.stringify(this.turnPlanner.getPlannedActions()))
        });
        this.eventBus.emit('BATTLE_LOG', { text: 'Planning committed.' });
        this.emitBattleUpdate();
    }

    unassignSlot(slotKey) {
        if (this.fsm.currentState !== 'BATTLE_LOOP' || this.battlePhase !== 'PLANNING') return;
        const res = this.turnPlanner.unassign(slotKey);
        if (!res.ok) {
            this.eventBus.emit('BATTLE_LOG', { text: res.reason || 'Cannot unassign slot.' });
            return;
        }
        if (res.removed) {
            this._freezePlannerToQueue();
            this._syncPlannerToRuntime();
            this.eventBus.emit('BATTLE_LOG', { text: `Removed action from ${slotKey}` });
            this.emitBattleUpdate();
        }
    }

    _freezePlannerToQueue() {
        this.playerSkillQueue = this.turnPlanner.getPlannedActions().map(a => ({
            ...a
        }));
    }

    _syncPlannerToRuntime() {
        const rt = this.data && this.data.dataConfig ? this.data.dataConfig.runtime : null;
        if (!rt) return;
        if (!rt.planning) rt.planning = {};
        if (!rt.planning.player) rt.planning.player = {};
        rt.planning.player.assigned = { ...this.turnPlanner.assigned };
        rt.planning.player.actionsById = { ...this.turnPlanner.actionsById };
        rt.planning.player.order = [...this.turnPlanner.order];
        rt.planning.player.skillCounts = { ...this.turnPlanner.skillCounts };

        rt.planning.player.plannedBySkill = { ...this.turnPlanner.plannedBySkill };
        rt.planning.player.skillToSlots = { ...this.turnPlanner.skillToSlots };
    }

    removeSkillFromQueue(index) {
        console.error('[CoreEngine] Deprecated input.removeSkillFromQueue called. Use input.unassignSlot(slotKey).', { index });
        this.eventBus.emit('BATTLE_LOG', { text: '已禁用旧接口 removeSkillFromQueue，请使用槽位取消接口。' });
        this.eventBus.emit('PLANNING_COMMIT_FAILED', {
            reason: 'Deprecated API removeSkillFromQueue called.',
            api: 'removeSkillFromQueue'
        });
    }

    commitTurn() {
        if (this.fsm.currentState !== 'BATTLE_LOOP' || this.battlePhase !== 'PLANNING') return;

        const tlPhase = this.timeline.phase;
        if (tlPhase !== 'READY') {
            this.eventBus.emit('BATTLE_LOG', { text: `Cannot execute: timeline is not READY (phase=${tlPhase}). Please commit planning first.` });
            return;
        }

        console.log('Execute turn (timeline playback).');
        this.battlePhase = 'EXECUTION';
        this.saveBattleState();
        this.emitBattleUpdate();

        this.executeTurn();
    }

    async executeTurn() {
        this.eventBus.emit('BATTLE_LOG', { text: `--- Execution Phase ---` });

        const timelineRes = await this.timeline.start({
            canContinue: () => this.fsm.currentState === 'BATTLE_LOOP'
        });

        if (!timelineRes.ok) {
            // TimelineManager will emit TIMELINE_ERROR; keep host in EXECUTION and expose issue.
            this.eventBus.emit('BATTLE_LOG', { text: `Timeline start failed: ${timelineRes.reason}` });
            this.emitBattleUpdate();
            return;
        }

        // If paused, stay in EXECUTION and wait for UI to resume.
        if (this.fsm.currentState === 'BATTLE_LOOP' && this.timeline.phase === 'PAUSED') {
            this.eventBus.emit('BATTLE_LOG', { text: 'Timeline paused.' });
            this.emitBattleUpdate();
            return;
        }

        // If FINISHED, the authoritative turn-advance is handled by TIMELINE_FINISHED event.
        if (this.fsm.currentState === 'BATTLE_LOOP' && this.timeline.phase === 'FINISHED') {
            return;
        }

        if (this.fsm.currentState === 'BATTLE_LOOP') {
            throw new Error(`Timeline ended in unexpected phase=${this.timeline.phase}`);
        }
    }

    _executeTimelineEntry(entry) {
        if (!entry || !entry.sourceAction) {
            throw new Error('Invalid timeline entry: missing sourceAction.');
        }

        // 检查战斗是否已经结束
        if (this.fsm.currentState !== 'BATTLE_LOOP') {
            return { skipped: true, reason: 'Battle loop ended.' };
        }

        const action = entry.sourceAction;
        const actionOrder = this.timeline.currentIndex + 1;

        let result = null;
        if (entry.side === 'self' || action.source === 'PLAYER') {
            result = this.executePlayerSkill(action);
        } else {
            result = this.executeEnemySkill(action);
        }

        if (this.currentHistoryEntry) {
            this.currentHistoryEntry.actions.push({
                order: actionOrder,
                ...action,
                result
            });
        }

        this.checkBattleStatus();
        return result;
    }

    executePlayerSkill(action) {
        const player = this.data.playerData;
        const skillConfig = this.data.getSkillConfig(action.skillId);
        
        if (!skillConfig) return null;

        // 扣除 AP（实际扣除）
        player.stats.ap -= action.cost;
        this.eventBus.emit('DATA_UPDATE', player);

        if (skillConfig.type === 'HEAL') {
            const healAmount = skillConfig.value;
            player.stats.hp += healAmount;
            if (player.stats.hp > player.stats.maxHp) player.stats.hp = player.stats.maxHp;
            
            const log = `Player used ${skillConfig.name} healed ${healAmount} HP!`;
            this.eventBus.emit('BATTLE_LOG', { text: log });
            this.emitBattleUpdate();
            return { isHit: true, heal: healAmount, targetHpRemaining: player.stats.hp };
        }

        const damage = skillConfig.value;
        let targetName = action.targetId;
        let result = { isHit: false, damage: 0 };
        
        if (this.data.currentLevelData && this.data.currentLevelData.enemies) {
            const enemy = this.data.currentLevelData.enemies.find(e => e.id === action.targetId);
            if (enemy) {
                if (enemy.hp <= 0) {
                    this.eventBus.emit('BATTLE_LOG', { text: `Target ${enemy.id} is dead, skill failed.` });
                    return { isHit: false, reason: 'dead' };
                }

                // Combat Context (Buff pipeline)
				const context = {
					attacker: player,
					target: enemy,
					skillId: action.skillId,
					bodyPart: action.bodyPart,
					rawDamage: damage,
					damageDealt: 0,
					damageTaken: 0,
					tempModifiers: Object.create(null)
				};
				this.eventBus.emit('BATTLE_ATTACK_PRE', context);

                // New Damage Logic: Armor -> HP
                let actualDamage = context.rawDamage;
                let armorDamage = 0;
                let targetPart = action.bodyPart || 'chest'; // Default to chest
                
                if (enemy.bodyParts && enemy.bodyParts[targetPart]) {
                    const part = enemy.bodyParts[targetPart];
                    
                    // Apply weakness
                    if (part.weakness) {
                        actualDamage = Math.floor(actualDamage * part.weakness);
                    }

                    // Apply armor mitigation mult from buffs (破甲等写入 tempModifiers)
					let armorMitMult = 1.0;
					const tmp = context.tempModifiers && context.tempModifiers.armorMitigationMult;
					if (Array.isArray(tmp) && tmp.length > 0) {
						for (const m of tmp) {
							if (m.type === 'percent_current') {
								armorMitMult *= (1 + m.value);
							} else if (m.type === 'flat') {
								armorMitMult += m.value;
							}
						}
					}

                    // Reduce Armor first (current)
                    if (part.current > 0) {
                        // armorMitMult > 1 => armor更“软”，等效为放大对护甲的穿透
						const mitigated = Math.ceil(actualDamage * armorMitMult);
						if (part.current >= mitigated) {
							part.current -= mitigated;
							armorDamage = mitigated;
                            actualDamage = 0;
                        } else {
							armorDamage = part.current;
							actualDamage = Math.max(0, mitigated - part.current);
                            part.current = 0;
                            part.status = 'BROKEN';
                        }
                    }
                }

                // TakeDamagePre hooks (e.g. shield / damage taken mult)
				context.damageTaken = actualDamage;
				this.eventBus.emit('BATTLE_TAKE_DAMAGE_PRE', context);
				if (context.damageTakenMult) {
					context.damageTaken = Math.floor(context.damageTaken * context.damageTakenMult);
				}
				if (context.shieldPool) {
					const absorbed = Math.min(context.shieldPool, context.damageTaken);
					context.damageTaken -= absorbed;
					context.shieldPool -= absorbed;
				}

                // Remaining damage goes to HP
                actualDamage = context.damageTaken;
                if (actualDamage > 0) {
                    enemy.hp -= actualDamage;
                    if (enemy.hp < 0) enemy.hp = 0;
                }

				context.damageDealt = actualDamage;
				this.eventBus.emit('BATTLE_ATTACK_POST', context);

                targetName = `${enemy.id} (HP: ${enemy.hp})`;
                result = { 
                    isHit: true, 
                    damage: actualDamage, 
                    armorDamage: armorDamage,
                    targetHpRemaining: enemy.hp,
                    targetPart: targetPart
                };
            }
        }

        const log = `Player used ${skillConfig.name} attacked ${targetName} for ${result.damage} HP damage (Armor: ${result.armorDamage})!`;
        this.eventBus.emit('BATTLE_LOG', { text: log });
        this.emitBattleUpdate();
        return result;
    }

    executeEnemySkill(action) {
        const player = this.data.playerData;
        if (player.stats.hp <= 0) return { isHit: false, reason: 'dead' };

        const skillConfig = this.data.getSkillConfig(action.skillId);
        const baseDamage = skillConfig ? skillConfig.value : 10;
        const skillName = skillConfig ? skillConfig.name : action.skillId;

        // Resolve attacker
		const enemy = (this.data.currentLevelData && this.data.currentLevelData.enemies)
			? this.data.currentLevelData.enemies.find(e => e.id === action.sourceId)
			: null;

		// Combat Context (Buff pipeline)
		const context = {
			attacker: enemy,
			target: player,
			skillId: action.skillId,
			bodyPart: action.bodyPart,
			rawDamage: baseDamage,
			damageDealt: 0,
			damageTaken: 0,
			tempModifiers: Object.create(null)
		};
		this.eventBus.emit('BATTLE_ATTACK_PRE', context);

        // New Damage Logic for Player
        let actualDamage = context.rawDamage;
        let armorDamage = 0;
        let targetPart = action.bodyPart || 'chest'; // Default to chest
        
        // Access player battle state for body parts
        const runtime = this.data.dataConfig.runtime;
        const playerBattleState = runtime ? runtime.playerBattleState : null;

        if (playerBattleState && playerBattleState.bodyParts && playerBattleState.bodyParts[targetPart]) {
            const part = playerBattleState.bodyParts[targetPart];
            
            // Apply weakness
            if (part.weakness) {
                actualDamage = Math.floor(actualDamage * part.weakness);
            }

            // Apply armor mitigation mult from buffs
			let armorMitMult = 1.0;
			const tmp = context.tempModifiers && context.tempModifiers.armorMitigationMult;
			if (Array.isArray(tmp) && tmp.length > 0) {
				for (const m of tmp) {
					if (m.type === 'percent_current') {
						armorMitMult *= (1 + m.value);
					} else if (m.type === 'flat') {
						armorMitMult += m.value;
					}
				}
			}

            // Reduce Armor first (current)
            if (part.current > 0) {
                const mitigated = Math.ceil(actualDamage * armorMitMult);
                if (part.current >= mitigated) {
                    part.current -= mitigated;
                    armorDamage = mitigated;
                    actualDamage = 0;
                } else {
                    armorDamage = part.current;
                    actualDamage = Math.max(0, mitigated - part.current);
                    part.current = 0;
                    part.status = 'BROKEN';
                }
            }
        }

        // TakeDamagePre hooks (e.g. shield / damage taken mult)
		context.damageTaken = actualDamage;
		this.eventBus.emit('BATTLE_TAKE_DAMAGE_PRE', context);
		if (context.damageTakenMult) {
			context.damageTaken = Math.floor(context.damageTaken * context.damageTakenMult);
		}
		if (context.shieldPool) {
			const absorbed = Math.min(context.shieldPool, context.damageTaken);
			context.damageTaken -= absorbed;
			context.shieldPool -= absorbed;
		}

		actualDamage = context.damageTaken;
        if (actualDamage > 0) {
            player.stats.hp -= actualDamage;
            if (player.stats.hp < 0) player.stats.hp = 0;
        }

		context.damageDealt = actualDamage;
		this.eventBus.emit('BATTLE_ATTACK_POST', context);
        
        this.eventBus.emit('DATA_UPDATE', player);
        
        const log = `${action.sourceId} used ${skillName} attacked Player for ${actualDamage} HP damage (Armor: ${armorDamage})!`;
        this.eventBus.emit('BATTLE_LOG', { text: log });
        this.emitBattleUpdate();

        return { 
            isHit: true, 
            damage: actualDamage, 
            armorDamage: armorDamage,
            targetHpRemaining: player.stats.hp 
        };
    }

    checkBattleStatus() {
        if (!this.data.currentLevelData || !this.data.currentLevelData.enemies) return;

        const enemies = this.data.currentLevelData.enemies;
        const player = this.data.playerData;

        // 检查胜利
        if (enemies.every(e => e.hp <= 0)) {
            this.endBattle(true);
            return;
        }

        // 检查失败
        if (player.stats.hp <= 0) {
            this.endBattle(false);
            return;
        }
    }

    endBattle(isVictory) {
        this.timeline.stop();
        const result = isVictory ? 'Victory' : 'Defeat';
        this.eventBus.emit('BATTLE_LOG', { text: `Battle Ended: ${result}!` });
        
        //  DataManager ???
        if (this.data.dataConfig.runtime) {
            delete this.data.dataConfig.runtime.levelData;
            delete this.data.dataConfig.runtime.turn;
            delete this.data.dataConfig.runtime.phase;
            delete this.data.dataConfig.runtime.initialState;
            delete this.data.dataConfig.runtime.history;
            delete this.data.dataConfig.runtime.queues;
            delete this.data.dataConfig.runtime.playerTempState;
        }
        this.data.currentLevelData = null;
        this.data.saveGame(); // ???

        this.fsm.changeState('BATTLE_SETTLEMENT', { victory: isVictory });
        this.eventBus.emit('BATTLE_END', { victory: isVictory });
    }

    resetTurn() {
        if (this.battlePhase !== 'PLANNING') {
            this.eventBus.emit('BATTLE_LOG', { text: `Cannot reset turn during ${this.battlePhase} phase.` });
            return;
        }

        // Clear planning (slots), queues, and timeline preview.
        this.turnPlanner.reset();
        this.playerSkillQueue = [];
        this.enemySkillQueue = [];
        this.timeline.reset();
        this._syncPlannerToRuntime();

        this.eventBus.emit('BATTLE_LOG', { text: 'Turn planning and timeline cleared.' });
        this.emitBattleUpdate();
    }
    
    saveBattleState() {
        if (this.fsm.currentState === 'BATTLE_LOOP') {
            if (!this.data.dataConfig.runtime) this.data.dataConfig.runtime = {};
            const runtime = this.data.dataConfig.runtime;
            runtime.turn = this.currentTurn;
            runtime.phase = this.battlePhase;
            
            // 保存队列
            if (!runtime.queues) runtime.queues = {};
            runtime.queues.player = this.playerSkillQueue;
            runtime.queues.enemy = this.enemySkillQueue;
        }
    }

    emitBattleUpdate() {
        // Merge runtime bodyParts into player data for UI
        let playerPayload = this.data.playerData;
        if (this.data.dataConfig.runtime && this.data.dataConfig.runtime.playerBattleState) {
             playerPayload = {
                 ...this.data.playerData,
                 bodyParts: this.data.dataConfig.runtime.playerBattleState.bodyParts
             };
        }

        this.eventBus.emit('BATTLE_UPDATE', {
            player: playerPayload,
            enemies: this.data.currentLevelData ? this.data.currentLevelData.enemies : [],
            turn: this.currentTurn,
            phase: this.battlePhase,
            timelinePhase: this.timeline ? this.timeline.phase : undefined,
            queue: this.playerSkillQueue
        });
    }
}

// 创建单例实例
const engineInstance = new CoreEngine();

// 挂载到 window 方便调试 (可选，但在本项目中为了兼容性保留)
window.Engine = engineInstance;

// 默认导出实例
export default engineInstance;

// 具名导出类 (用于测试或特殊需求)
export { CoreEngine };
